---
layout: page
#
# Content
#
title: ""
teaser: ""
header:
    image_fullwidth: "bordeaux-small.jpeg"
    permalink: "/"
---

# Résumés

## Soumission #1

### Titre

LAMP: Une Approche Efficace pour la Détection de Fautes dans les Systèmes Distribués

### Résumé

La détection des fautes constitue un élément clé pour assurer la fiabilité et la sécurité des
systèmes distribués. Cependant, les approches existantes, telles que l’audit décentralisé et les
preuves cryptographiques, entraînent un coût significatif en termes de ressources. Elles im-
pliquent une consommation accrue de CPU et de bande passante en raison des échanges né-
cessaires à la détection des fautes et du rejeu des opérations pour vérifier l’intégrité des appli-
cations auditées. Cette surcharge peut impacter directement les performances des applications
surveillées, en augmentant la latence, en mobilisant des ressources supplémentaires et, dans
certains cas, en interrompant leur exécution pour effectuer des contrôles.
Ce travail explore LAMP, un protocole qui exploite les Environnements d’Exécution de Confiance
(TEEs) afin de structurer différemment l’audit des systèmes distribués. LAMP propose une cen-
tralisation partielle du processus de vérification au sein de nœuds de confiance, réduisant ainsi
la charge sur l’ensemble du système. Par ailleurs, l’intégrité des journaux est assurée par des
mécanismes garantissant l’inaltérabilité des enregistrements, limitant ainsi les risques de falsi-
fication.
Les travaux sur LAMP sont à un stade préliminaire et nécessitent des évaluations complé-
mentaires, en particulier sur son impact en termes de consommation énergétique et sur les
performances des applications auditées. Une analyse approfondie est nécessaire pour mesurer
le compromis entre sécurité, coût computationnel et latence, et ainsi déterminer dans quelles
conditions cette approche peut être adoptée dans des environnements réels

### Auteurs

- Lamyae Hassini (Université de Bordeaux)
- Joachim Bruneaux-Queyreix (Université de Bordeaux)
- Laurent Réveillère (Université de Bordeaux)

### Sujet

- Système

### Type de présentation

Poster seul, sans présentation

---

## Soumission #2

### Titre

AUPE : Protocole collaboratif d’échantillonnage de pairs tolérant aux fautes byzantines

### Résumé

L’échantillonnage de pairs constitue une primitive fondamentale dans les systèmes distribués,
permettant le partage d’informations à grande échelle, notamment dans les blockchains. Son
objectif est de maintenir et de mettre à jour dynamiquement une vue locale et partielle de l’en-
semble des membres du système. Cependant, ces protocoles sont vulnérables aux attaques de la
part d’adversaires cherchant à perturber le fonctionnement des protocoles de plus haut niveau
de la blockchain. En particulier, un adversaire contrôlant un ensemble de nœuds byzantins
peut manipuler la perception des nœuds honnêtes en augmentant la représentation des nœuds
malveillants dans leur vue locale.
Bien que les protocoles d’échantillonnage de pairs tolérants aux fautes byzantines présent dans
la littérature atténuent en partie ce biais, leur efficacité diminue significativement à mesure que
la proportion de nœuds malveillants dans le système augmente. Cet article introduit AUPE, le
premier protocole collaboratif d’échantillonnage de pairs tolérant aux fautes byzantines. AUPE
exploite la présence de nœuds de confiance, tels que des dispositifs compatibles avec Intel SGX,
afin de suivre de manière collaborative la propagation des identifiants au sein du système et de
réajuster localement la représentation des nœuds byzantins.
Des simulations menées sur un réseau de 10 000 nœuds montrent qu’AUPE surpasse les so-
lutions de l’état de l’art, atteignant une résilience quasi parfaite même face à un adversaire
contrôlant jusqu’à 26% des nœuds. En intégrant seulement 10% de nœuds de confiance, AUPE
améliore la tolérance du protocole BRAHMS de 60%, tout en réduisant considérablement l’im-
pact des attaques adversariales, y compris lorsque l’adversaire possède jusqu’à 40% des nœuds.

### Auteurs

- Augusta Mukam (Université de Bordeaux)
- Joachim Bruneau-Queyreix (Université de Bordeaux)
- Laurent Réveillère (Université de Bordeaux)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #3

### Titre

Checkpointing optimisation to prepare future exascale plasma turbulence simulations

### Résumé

The advent of exascale computing has revolutionized high-performance computing (HPC) and enabled unprecedented advancements in nuclear fusion research. Simulations of plasma turbulence dynamics, such as the GYSELA code, now achieve unparalleled precision and complexity. However, this progress is accompanied by significant challenges in managing the exponential growth of data generated by these simulations. Traditional input/output (I/O) methods struggle to handle the massive data volumes, heightened concurrency, and fault-tolerance requirements inherent to exascale systems.

This paper investigates the I/O bottlenecks inherent in exascale computing, with a particular focus on the checkpointing mechanisms of GYSELA. These mechanisms are critical for ensuring fault tolerance and must handle several terabytes of data efficiently to avoid undermining computational performance. We analyze the current implementation of GYSELA's checkpointing mechanism managed via the PDI data interface, identifying its limitations and proposing two alternative approaches aimed at enhancing scalability and resilience.
Experiments conducted on pre-exascale architectures validate the efficiency of these methods through both strong and weak scaling benchmarks. We reduced the checkpointing execution time by a factor of four, achieving near-optimal bandwidth utilisation, and we have identified implementations well-suited for exascale architectures.
Our findings suggest the potential for notable performance improvements and offer insights that could help optimise I/O operations in exascale simulations.

### Auteurs

- Méline TROCHON (INRIA BORDEAUX)

### Sujet

- Architecture
- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #4

### Titre

Co-conception sécurisante entre le back-end d’un compilateur et un système matériel

### Résumé

Les systèmes matériels sur lesquels s'exécutent les logiciels sont, par nature, vulnérables aux attaques physiques. Il existe de nombreuses contremesures matérielles ou bien logicielles visant à protéger un système matériel et logiciel de ces attaques. De multiples vulnérabilités sont régulièrement découvertes, nécessitant de nouvelles contremesures. Ces contremesures ne font majoritairement état que de solutions exclusivement matérielles ou logicielles.

Cependant, si l'on souhaite un système sécurisé, il faut co-concevoir le matériel et le logiciel afin de :
   - s'assurer que les propriétés de sécurité matérielles sont exprimées au niveau du back-end;
   - exploiter les fonctionnalités de sécurité matérielles à disposition;
   - corriger les vulnérabilités restantes au niveau matériel via des contremesures logicielles;

Certaines contributions de ce domaine proposent de créer, ou d'étendre de nouveaux jeux d'instructions pour des architectures (ISA). D'autres proposent de nouvelles techniques de génération de code, en plus de l'extention/modification d'ISA sur des processeurs.


Complémentairement, les contrats matériel/logiciel, proposent une manière formelle de prouver qu'une instruction d'ISA sécurise ou non le système, grâce à la formalisation des vulnérabilités matérielles. Cela permet de définir des contremesures formelles aux vulnérabilités.


Notre objectif dans cette thèse est l'utilisation et l’extension des contrats matériel/logiciel pour prendre en compte la génération de code sécurisé, c'est-à-dire exprimer les propriétés de sécurité au niveau de la conception matérielle et du back-end de compilateur.
Pour cela, nous prévoyons de:  
    - créer des techniques de génération de code, par développement de passes de back-end du compilateur LLVM, qui évitent des vulnérabilités matérielles connues matériel-spécifiques;
    - proposer une méthodologie de co-conception matériel/back-end de compilateur pour la sécurité, validée formellement via les contrats.

MotsClés: Attaques matérielles, RISC-V, génération de code LLVM, codesign matériel/logiciel

### Auteurs

- Clara BOURGEAIS (LCIS - Grenoble INP - UGA)
- Laure GONNORD (LCIS - Grenoble INP - UGA)
- David HÉLY (LCIS - Grenoble INP - UGA)

### Sujet

- Architecture

### Type de présentation

Présentation avec poster

---

## Soumission #5

### Titre

Un modèle d’intelligence artificielle pour détecter et corriger des erreurs dans du code MPI

### Résumé

En calcul haute performance et notamment dans le modèle de programmation MPI, les erreurs de programmation peuvent être très complexes et nécessiter l'exécution d'outils de détection automatisés pour être identifiées. Cependant, les outils disponibles actuellement ne répondent pas au besoin croissant d'assistance à la programmation. Les outils statiques qui s'appliquent sur le code source sont peu coûteux à exécuter mais ils sont également trop peu précis. Inversement, les outils dynamiques qui nécessitent l'exécution du programme sont plus précis sur leur détection d'erreur mais très coûteux à utiliser. L'utilisation de l'intelligence artificielle pour détecter et corriger des erreurs dans du code est une pratique de plus en plus courante, avec notamment des outils comme GitHub Copilot ou GPT-4, mais les modèles actuels sont très généraux et peu adaptés aux problèmes spécifiques du calcul haute performance. Nous cherchons alors à savoir s'il est possible de développer un outil de détection et de correction grâce à l'intelligence artificielle pour identifier, à moindre coût et avec une grande précision, la présence ou non d'erreurs dans du code MPI.

Un des principaux défis soulevés par cette étude étant qu'il n'existe pour l'instant aucune base de données d'erreurs réelles en calcul haute performance, nous proposons une nouvelle base de données composée à partir de programmes en MPI récupérés de plusieurs milliers de projets open-source depuis GitHub. Nous trions et filtrons ces fichiers, puis nous introduisons des erreurs par mutation synthétique du code source, avec l'objectif de reproduire le plus fidèlement possible le comportement de programmeurs et programmeuses qui pourraient faire ces erreurs naturellement. Nous représentons ensuite les fichiers mutés par des vecteurs d'embedding, qui nous serviront à entraîner des modèles de détection d'erreur. Nous voulons étudier la précision et la capacité de généralisation de tels modèles sur des données nouvelles et réalistes. Dans le futur, nous voudrions apprendre à générer du code correct à partir d'une erreur. Pour cela, nous envisageons de représenter sous forme d'un unique vecteur la différence entre deux versions d'un même code, avant et après une modification, afin de caractériser ce changement en fonction des erreurs introduites ou corrigées.

### Auteurs

- Asia Auville (Centre Inria de l'université de bordeaux)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #6

### Titre

Performance de Proxmox pour les Applications HPC en Contextes de Partage de Ressources

### Résumé

Cette étude compare les performances de la plateforme de virtualisation Proxmox et de l'hyperviseur KVM, en les comparant à un environnement bare-metal dans un contexte HPC. Les résultats montrent que, en mode compétitif, Proxmox présente une perte de performance de 6\% à 12\% par rapport au bare-metal et de 5\% à 10\% par rapport à KVM dans les tests CPU intensifs. En mode coopératif, Proxmox affiche une augmentation de latence de 8\% par rapport à KVM. L'analyse de l'utilisation des ressources révèle une consommation mémoire 5\% supérieure sous Proxmox. Bien que Proxmox introduise une légère surcharge, ses performances restent compétitives pour les applications HPC dans des environnements virtuels, offrant une solution efficace pour la gestion centralisée et flexible des ressources.

### Auteurs

- Aurélien Izoulet (École Pour l'Informatique et les Techniques Avancées (EPITA))
- David Beserra (École Pour l'Informatique et les Techniques Avancées (EPITA))

### Sujet

- Architecture
- Parallélisme
- Système

### Type de présentation

Présentation sans poster

---

## Soumission #7

### Titre

MLKAPS : Machine Learning and Adaptive Sampling for HPC Kernel Auto-tuning

### Résumé

We introduce a novel auto-tuning tool, MLKAPS, designed to address the challenges of optimizing high-performance computing (HPC) kernel parameters. MLKAPS generates decision trees that provide an efficient parameter configuration for any user input. It replaces manually tuned configurations, which are resource-intensive to collect, prone to human bias, and often result in suboptimal performance in certain input regions. MLKAPS automates this process using machine learning and adaptive sampling, significantly improving efficiency and scalability.

We introduce a novel sampling strategy, GA-Adaptive, which balances exploration and exploitation in high-dimensional search spaces. By iteratively refining a surrogate model built with Gradient Boosting Decision Trees (GBDT), MLKAPS identifies optimized configurations and leverages transfer-learning to efficiently optimize many inputs. This approach allows MLKAPS to adapt to diverse hardware architectures and input spaces without manual intervention.

The effectiveness of MLKAPS is demonstrated on two Intel Math Kernel Library (MKL) kernels: dgetrf (LU) and dgeqrf (QR). The results indicate that MLKAPS outperforms hand-tuned configurations by achieving a geometric mean speedup of x1.30 on 85\% of the input space, and highlights blind spots in the existing manual tuning. Compared to state-of-the-art tools like Optuna and GPTune, MLKAPS achieves faster convergence, better scalability, and superior performance in larger design spaces. On the Scalapack PDGEQRF kernel taken from the GPTune examples, MLKAPS not only outperforms GPTune in terms of final performance, it also collects more samples for a fraction of the cost in both time and memory.

Beyond its performance gains, MLKAPS provides practical advantages by generating decision trees that can be embedded directly into HPC kernels. The runtime overhead is minimal and it enables simplified deployment in production environments. Future work will focus on extending MLKAPS to support more kernel types, smarter exploration of the input space, and refined decision trees to maximize performance and deployability.

### Auteurs

- Mathys Jam (Université Paris-Saclay, UVSQ, LI-PaRAD)
- Eric Petit (Intel Corp.)
- Pablo de Oliveira Castro (Université Paris-Saclay, UVSQ, LI-PaRAD)
- David Defour (Université de Perpignan via Domitia, LAMPS)
- Greg Henry (Intel Corp.)
- William Jalby (Université Paris-Saclay, UVSQ, LI-PaRAD)

### Sujet

- Architecture

### Type de présentation

Présentation sans poster

---

## Soumission #8

### Titre

High Performance Solver for Aeroacoustic Simulations for Airbus

### Résumé

As a part of system design tasks, Airbus simulates the acoustic vibrations sustained by mechanical components during take-off to ensure minimal noise pollution and the prevention of component damage. These simulations involve solving a coupled sparse-dense linear system, which results from modeling the heterogeneous medium of jet engine flow (with Finite Element Method, FEM) and the homogeneous medium of aircraft surface (with Boundary Element Method, BEM), respectively. Given the massive scale of these sparse-dense coupled systems (hundreds of millions of FEM unknowns and millions of BEM unknowns), optimizing computational time and memory usage is essential. Despite significant advances in dense and sparse direct solvers, their application to coupled sparse/dense systems has been under-explored. In this presentation, the first aim is to empirically evaluate the existing sparse-dense solver combinations to solve these coupled systems. The second aim is to discuss, through experimental results, if solving the whole coupled system with only H-mat solver is more efficient than using two different solvers to avoid the overhead of coupling two existing non-adapted solvers.

### Auteurs

- Emmanuel Agullo (Inria center at the university of Bordeaux)
- Esragul Korkmaz (Inria center at the university of Bordeaux)
- Guillaume Sylvand (Airbus)

### Sujet



### Type de présentation

Présentation sans poster

---

## Soumission #9

### Titre

État des connaissances sur la gestion de la responsabilité pour les microcontrôleurs multi-parties dans le Continuum Cloud-to-IoT

### Résumé

Les solutions de conteneurisation légère permettent l'exécution sécurisée sur microcontrôleur d'applicatifs venant de plusieurs acteurs se méfiant mutuellement les uns des autres. Ce nouveau paradigme pose des problèmes de gestion des responsabilités étant donné que les modèles de surveillance actuels sont prévus pour des micrologiciels (firmware) monolithiques et que les mécanismes d'autres infrastructures comme le Cloud ne sont pas adaptés aux contraintes des microcontrôleurs. Cet article fournit un état des connaissances sur ce sujet. Premièrement, nous définissons l'architecture des microcontrôleurs multi-parties et ses différentes parties prenantes.
Ensuite, nous analysons la capacité de plusieurs solutions de conteneurisation à assurer des engagements sur des microcontrôleurs multi-parties. Finalement, nous examinons les méthodes permettant aux différents acteurs de vérifier le respect des engagements. Cette étude souligne le besoin d'améliorer les solutions de conteneurisation pour prendre en compte les engagements, notamment de performances, ainsi que le besoin de méthodes de vérifications des engagements adapté aux contraintes des locataires déployant leur conteneur.

### Auteurs

- Bastien Buil (CNAM / Orange)
- Chrystel Gaber (Orange)
- Samia Bouzefrane (Cnam)
- Emmanuel Baccelli (Inria)

### Sujet

- Architecture

### Type de présentation

Présentation avec poster

---

## Soumission #10

### Titre

Porting the Gysela code on GPU enabled supercomputers

### Résumé

This study describes the porting of high-dimensional operators on accelerators involving complex memory patterns and memory usage requirements which appear in five dimensional fusion plasma turbulence codes such as GYSELA. Motivated by the gyrokinetic simulations' huge computational needs, the porting of GYSELA, one of the few international 5D gyrokinetic codes able to perform global, full-f and flux-driven simulations, lead to a "partial rewrite" of the code with the addition of OpenMP annotations allowing the offloading of the work to a device such as but not limited to, GPUs. We focus on the porting workflow applied to GYSELA, we present the limitations of the programming model implementation used and show that the externalization of a problematic operator and rewriting it in Kokkos is indeed viable and that the return on investment is positive with it being reusable by other codes. A set of benchmarks on the Adastra parallel machine has permitted us to evaluate the performance of the resulting code on a subset of the latest GPU (AMD MI250X), APU (AMD MI300A) and CPU (AMD GENOA) technologies. We discuss the remaining bottlenecks and problems after the porting of the algorithms. Some possible solutions are foreseen.

### Auteurs

- Etienne Malaboeuf (Cines)
- Mathieu Peybernes (EPFL)
- Kevin Obrejan (CEA)
- Virginie Grandgirard (CEA)

### Sujet

- Architecture
- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #11

### Titre

Isolation et Protection des SoC : Les TEE dans les Applications Embarquées

### Résumé

Avec le ralentissement de la loi de Moore, les System-on-Chip (SoC) hétérogènes sont de plus en plus présents dans les systèmes embarqués. Ces systèmes regroupent sur une même puce des composants de nature différente, tels que des processeurs, des mémoires, des accélérateurs matériels et des périphériques. Cependant, cette diversité de composants présente un inconvénient majeur pour la sécurité. Chaque composant introduit des vulnérabilités qui lui sont propres, et les interactions entre les composants peuvent également ouvrir de nouveaux vecteurs d'attaques. Aussi, l'effort nécessaire pour assurer la sécurité du SoC augmente avec le nombre de composants qu'il contient. En réponse à ces défis, de nombreux travaux ont proposé des solutions pour renforcer la sécurité, soit au niveau des composants individuels, soit au niveau de l'architecture globale du SoC. Parmi les solutions proposées dans la littérature, une approche très populaire consiste à isoler les composants (logiciels et matériels) du SoC que le concepteur considère comme critiques, du reste des composants du SoC qu'un adversaire pourrait corrompre. Un riche écosystème de systèmes en isolation (Trusted Execution Environments) existe, marqué par une forte dualité entre le domaine académique et le domaine commercial, ce dernier étant dominé par un petit nombre de solutions. Cette dichotomie peut, en partie, s'expliquer par le surcoût induit par le déploiement de ces solutions sur les performances globales du système. Dans cette présentation, nous proposons d'étudier cet écosystème particulier et de comprendre les défis qui limitent l'adoption de nouvelles solutions dans le domaine commercial. Nous proposerons une taxonomie des différentes solutions actuelles en les distinguant sur la base des stratégies d'isolation qu'elles emploient, et nous identifierons les principaux axes de recherche à privilégier pour améliorer l'acceptabilité des nouvelles solutions dans le domaine commercial. En particulier, nous mettrons en avant l'importance de trouver des compromis sécurité/performance acceptables en fonction des applications.

### Auteurs

- Simon Baissat-Chavent (Université Jean-Monnet de ST-Etienne)
- Lilian Bossuet (Université Jean-Monnet de ST-Etienne)
- Cédric Killian (Université Jean-Monnet de ST-Etienne)

### Sujet

- Architecture

### Type de présentation

Présentation sans poster

---

## Soumission #12

### Titre

Interruptions en espace utilisateur depuis le réseau BXI pour le recouvrement calcul/communications

### Résumé

En HPC, les supercalculateurs sont composés de noeuds interconnectés par un réseau haute
performance, comme par exemple le réseau BXI d’Eviden. La carte BXI exécute la plupart des
tâches de communications par elle-même ; cependant, l’application doit être prévenue de l’arrivée
de messages. Pour celà, elle peut utiliser une scrutation ou des interruptions. Pour maximiser
le temps dédié au calcul, il est préférable d’éviter la scrutation. Un mécanisme d’interruptions
qui traite les évènements puis retourne au calcul évite les appels inutiles. En revanche, les
réseaux haute performance se programment depuis l’espace utilisateur pour éviter le coût des
appels systèmes. Or, un mécanisme d’interruption classique passe par le noyau, ce que l’on
cherche à éviter. Le mécanisme d’interruptions en espace utilisateur est disponible sur certains
processeurs récents. Cependant, seul l’envoi entre deux coeurs est disponible pour l’instant.
Notre contribution est un mécanisme qui permet de lever une interruption en espace utilisateur
à partir d’un périphérique PCIe. Pour ce faire, nous utilisons le mécanisme interrupt-posting
de l’IOMMU, qui n’est pas prévue pour les interruptions en espace utilisateur. Nous avons
détourné le mécanisme pour transformer des interruptions classiques en interruptions en espace
utilisateur. Nous avons également adapté la bibliothèque Portals ainsi que le module noyau BXI
pour y ajouter le support des UINTR.
La latence est de 1.5µs pour la scrutation, de 3.6µs avec les interruptions en espace utilisateur et
de 9µs avec les interruptions classiques. Pour le recouvrement des communications par du calcul,
nous avons étendu la suite de bench overlap pour ajouter un support direct des opérations de
la spécification Portals 4, avec un mécanisme de rendez-vous basique simulant un protocole
MPI. Nous observons un recouvrement mauvais en scrutation, et presque parfait avec les UINTR.
La suite de nos travaux porte sur l’intégration des interruptions en espace utilisateur dans la
bibliothèque de communications NewMadeleine.

### Auteurs

- Charles Goedefroit (Eviden, Univ. Bordeaux)
- Alexandre Denis (Centre Inria de l'université de Bordeaux)
- Brice Goglin (Centre Inria de l'université de Bordeaux)
- Mathieu Barbe (Eviden)
- Grégoire Pichon (Eviden)

### Sujet

- Parallélisme
- Système

### Type de présentation

Présentation avec poster

---

## Soumission #13

### Titre

Towards Designing an Energy Aware Data Replication Strategy for Cloud Systems Using Reinforcement Learning

### Résumé

The rapid growth of global data volumes has created a demand for scalable distributed systems that can maintain a high quality of service. Data replication is a widely used technique that provides fault tolerance, improved performance and higher availability. Traditional implementations often rely on threshold-based activation mechanisms, which can vary depending on workload changes and system architecture. System administrators typically bear the responsibility of adjusting these thresholds. To address this challenge, reinforcement learning can be used to dynamically adapt to workload changes and different architectures. In this paper, we propose a novel data replication strategy for cloud systems that employs reinforcement learning to automatically learn system characteristics and adapt to workload changes. We present the architecture behind our solution and describe the reinforcement learning model by defining the states, actions and rewards.

### Auteurs

- Amir Najjar (Institut de recherche en informatique de Toulouse)
- Riad Mokadem (Institut de recherche en informatique de Toulouse)
- Jean-Marc Pierson (Institut de recherche en informatique de Toulouse)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #14

### Titre

AI Optimization on embedded systems

### Résumé

Recent advancements have shown the importance of embedding Artificial Intelligence (AI) models into devices with constraints on size, power, and processing capabilities. This integration aims to develop intelligent and efficient technologies that operate within the limitations of everyday devices. Consequently, the hyperparameters for designing these models must be carefully selected to balance prediction efficiency, embeddability, and operational requirements.

Traditional hyperparameter selection methods prioritize prediction efficiency without considering resource constraints, often resulting in complex models that require more hardware resources. While some recent studies have suggested optimizing models for specific hardware environments, the software and hardware design processes remain largely disconnected.

In our research, we propose a compreh8ensive approach that optimizes model selection and parameterization using conventional software tools like TensorFlow from the design phase itself, incorporating hardware and operational constraints. We explore both static and dynamic design phases to meet operational constraints such as bandwidth and latency. The static approach assumes consistent inference for all samples, whereas the dynamic approach adapts based on operational constraints.

Our first contribution involves hyperparameter search and optimization for embedded targets. This includes selecting training parameters and architecture parameters, validated on FPGAs with Random Forest, Neural Networks, and Convolutional Neural Networks. We implement a 2-step optimization method for FPGAs, predicting resources like latency, energy, and hardware usage using polynomial regressors derived from initial implementation trials. Metaheuristics like Bayesian optimization and genetic algorithms are employed to optimize parameters, generating a set of solutions visualized via a Pareto front for model selection. A secondary “low-level” optimization refines implementation parameters.
The second contribution focuses on dynamic adaptation techniques for real-time constraints, such as resource availability or energy consumption. By leveraging techniques like early exits and gated inference mechanisms, we enable adaptive inference, tailoring the inference phase dynamically based on external factors or contextual samples.
While our static optimization method has been validated across several models and constraints, our dynamic method is in the implementation phase, necessitating further experiments to confirm its theoretical benefits. Overall, our work demonstrates promising advancements in embedding AI models in constrained environments, with potential for broader applications across various AI and hardware targets.

### Auteurs

- Kevin Druart (UBO/Lab-STICC/Thales DMS)
- David Espes (UBO/Lab-STICC)
- Catherine Dezan (UBO/Lab-STICC)
- Alain Deturche (Thales DMS)

### Sujet

- Architecture
- Système

### Type de présentation

Poster seul, sans présentation

---

## Soumission #15

### Titre

ArmoniK : une solution open source pour l’orchestration et la distribution de calculs

### Résumé

Dans un contexte où les besoins en calcul haute performance (HPC) et en traitement massif des données ne cessent de croître, ArmoniK est une plateforme open-source conçue pour l’exécution efficace et évolutive de charges de travail parallèles. Compatible avec des infrastructures hétérogènes, elle vise à simplifier le développement et le déploiement industriel de calculs distribués tout en optimisant l’utilisation des ressources, qu’il s’agisse de clouds publics ou privés, et bientôt, de clusters HPC. ArmoniK s'applique à permettre aux utilisateurs de se concentrer sur le développement de leurs applications sans se soucier de la complexité sous-jacente liée à l’exécution distribuée.

L’orchestrateur de calcul ArmoniK propose nativemment la distribution dynamique de graphes de tâches de calcul et de leurs données associées, la tolérance aux pannes, l’élasticité, la portabilité et l’observabilité. Il permet d’exécuter des charges de travail parallèles sous la forme de tâches indépendantes ou dépendantes, en gérant automatiquement leur ordonnancement et leur distribution sur les ressources disponibles. La gestion des échecs est intégrée à travers des mécanismes de reprise automatique des tâches en cas de panne, garantissant une exécution fiable et robuste. Grâce à une gestion fine de l’orchestration des tâches et à son architecture élastique, ArmoniK assure une mise à l’échelle dynamique et optimale, s’adaptant aux variations de charge tout en maintenant un haut niveau de performance, assurant ainsi une scalabilité horizontale. Reposant sur une architecture modulaire et orientée microservices, ArmoniK propose un modèle de distribution qui maximise l’exploitation des ressources disponibles tout en réduisant la latence. De plus, la plateforme offre des SDKs en plusieurs langages (C++, Python, Rust, C#, Java) pour simplifier le développement d’applications distribuées.

Cette présentation détaillera les principes architecturaux d’ArmoniK, ses performances sur différents cas d’usage et les perspectives d’évolution.

ArmoniK s’inscrit ainsi dans une démarche visant à répondre aux défis liés à la montée en charge, à l’optimisation des ressources et à la gestion efficace des calculs distribués dans des environnements complexes. En offrant une abstraction de haut niveau, la plateforme facilite le développement et le déploiement d’applications de calcul intensif à large échelle, tout en garantissant une utilisation optimale des infrastructures sous-jacentes.

### Auteurs

- Jérôme Gurhem (Aneo)
- Wilfried Kirschenmann (Aneo)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #16

### Titre

Vers un système de réservation de ressources basée sur NDN pour le computing continuum

### Résumé

Cet article présente NRN, un système de réservation de ressources permettant à l'utilisateur de formuler des besoins en ressources. Chaque ressource disponible (CPU, RAM, GPU, etc.) reçoit un nom unique selon le modèle NDN. NRN est un système de réservation de bout en bout qui fournit un moyen de découvrir des ressources à travers le réseau et de formuler des exigences réseau pour atteindre la ressource réservée.
Il tire parti du contexte du computing continuum et est capable d'exploiter des ressources n'importe où dans le réseau, que ce soit des équipements situés à l'edge, des infrastructures cloud ou des équipements de réseau.

### Auteurs

- Thierry ARRABAL (Laboratoire CITI - Bâtiment Hedy Lamar - 6 Av. des arts 69100 Villeurbanne - France)
- Julien CAPOSIENA (Laboratoire CITI - Bâtiment Hedy Lamar - 6 Av. des arts 69100 Villeurbanne - France)
- Frédéric LE MOUËL (Laboratoire CITI - Bâtiment Hedy Lamar - 6 Av. des arts 69100 Villeurbanne - France)
- Stéphane FRÉNOT (Laboratoire CITI - Bâtiment Hedy Lamar - 6 Av. des arts 69100 Villeurbanne - France)

### Sujet

- Architecture
- Système

### Type de présentation

Présentation sans poster

---

## Soumission #17

### Titre

Distributed Topological Data Analysis with TTK and MPI

### Résumé

Topological Data Analysis (TDA) is an ensemble of methods that extract characteristics of a 2D or 3D dataset in order to facilitate its representation and analysis. Applications include a variety of domains such as fluid dynamics, chemistry or astrophysics. The Topology ToolKit (TTK) is an open-source framework that implements a number of those TDA methods to allow for efficient and robust computations. However, up until now, TTK has only been parallelized in a shared-memory context, limiting the size of the datasets it can process.
In this talk, we will present the results of our paper, "TTK is Getting MPI-Ready". 
It documents the technical foundations for the extension of TTK to distributed-memory parallelism with the Message Passing Interface (MPI). While several recent papers introduced topology-based approaches for distributed-memory environments, these were reporting experiments obtained with tailored, mono-algorithm implementations. In contrast, we describe a versatile approach for the support of topological analysis pipelines, i.e. a sequence of topological algorithms interacting together. While developing this extension, we faced several algorithmic and software engineering challenges, which we documented. We describe an MPI extension of TTK's data structure for triangulation representation and traversal, a central component to the global performance and generality of TTK's topological implementations. We provide a taxonomy for the distributed-memory topological algorithms supported by TTK, depending on their communication needs and provide examples of hybrid MPI+thread parallelizations. Performance analyses show that parallel efficiencies range from 20% to 80% (depending on the algorithms), and that the MPI-specific preconditioning introduced by our framework induces a negligible computation time overhead. We illustrate the new distributed-memory capabilities of TTK with an example of advanced analysis pipeline, combining multiple algorithms, run on the largest publicly available dataset we have found (120 billion vertices) on a cluster with 64 nodes (for a total of 1536 cores). We also provide a roadmap for the completion of TTK's MPI extension, along with generic recommendations for each algorithm communication category. Finally, we will present our latest work to port the computation of a more complex topological representation to a distributed-memory context.

### Auteurs

- Eve Le Guillou (Sorbonne Université - CNRS)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #18

### Titre

Scalable Domain Decomposition Methods for Large Sparse Linear Systems on Modern Architectures

### Résumé

In this work, we address the challenge of scaling domain decomposition
methods for solving large sparse linear systems on modern
architectures. We leverage the Composyx software framework,
integrating state-of-the-art libraries such as BLAS/LAPACK for dense
linear algebra, direct sparse solvers for subproblem resolution, and
efficient partitioners for domain decomposition. Ensuring seamless
integration and optimal resource utilization is critical for
computational efficiency.

We first optimize these methods for homogeneous multi-core systems,
refining each algorithmic stage to minimize overhead and fully exploit
shared memory within each domain. A key aspect of this optimization is
ensuring that each library efficiently utilizes multi-core
architectures through Composyx, both independently and within a shared
execution context. Additionally, proper thread and process placement
is crucial, ensuring that each process is bound to a specific portion
of the machine for optimal performance. To better understand the
effectiveness of these optimizations, we will conduct an in-depth
analysis of the trade-offs between computational and numerical
factors, specifically the number of cores assigned per domain versus
the number of domains. The goal is to identify the best configuration
that balances parallel efficiency, numerical accuracy, and overall
solver performance. This study will provide valuable insights into how
domain decomposition methods can be adapted to different problem sizes
and hardware configurations, ensuring robustness and scalability.
Building on this foundation, ongoing work focuses on extending our
framework to heterogeneous CPU-GPU architectures through a
fine-grained task-based parallelization strategy.

By addressing these challenges related to increasing platform
heterogeneity and algorithmic complexity, this work seeks to ensure
that domain decomposition methods remain robust, scalable, and
well-suited to the computational demands of large-scale simulations in
the exascale era.

### Auteurs

- Stojche Nakov (Inria)
- Emmanuel Agullo (Inria)
- Luc Giraud (Inria)
- Gilles Marait (Inria)
- Alfredo Buttari (Irit)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #19

### Titre

Increasing parallelism through software decomposition of individual-based simulations : A case study of the Aevol genome evolution simulator

### Résumé

Individual-based simulation models are widely spread and have applications ranging from the bio-medical domain to finance and computer networking. Such models expose easy parallelism when most of the computational work is independent between individuals. But heterogeneity in workload between individuals lead to scheduling irregularities, that need to be addressed.
    
Instead of improving scheduling, it can be worth to expose inner parallelism in individuals, but it needs to break fairly complex and intertwined sequential processes. 
We propose a new programming model, that tries to address this issue, by separating the inherent computational bulk from the sequential work. Specifically, it adopts a two-tiered architecture, with a symbols extraction phase, followed by a parsing automaton, which concentrates the model logic. The first phase is the main focus of this paper, and a highly-parallel section. All of the sequential work is gathered in the second part, thus reducing the critical path.
    
The increase in parallelism coupled with a minimization of sequential sections allowed this software model to be ported successfully to GPU, achieving significant speedup for some simulation parameters, and allowed to run several orders of magnitude larger simulations in comparable amounts of time, as opposed to an individually-based parallel implementation. 
We evaluate the effectiveness of this new architecture through a series of experiments, based on an implementation of the Aevol model, an individual-based simulation software modeling genome evolution. Experiments were conducted on various platforms, including state-of-the-art GPUs and many-core CPU architectures.

### Auteurs

- Romain Gallé (Inria / LIRIS / CITI)
- Jonathan Rouzaud-Cornabas (INSA de Lyon / LIRIS / CITI)
- Thierry Gautier (Inria / LIP)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #20

### Titre

Exa-AToW data logistics framework for cross-facility scientific workflows

### Résumé

The Exa-AToW [1] vision defines large-scale workflows, also called cross-facility [8] or multi-
facility [10] workflows, as portable scientific processes designed to operate across distributed
and heterogeneous infrastructures in order to simplify and automate complex data processing
and analysis tasks. Large-scale workflows can be seen as a collaborative system-of-systems, an
assembly of independent systems that voluntarily interact to achieve shared objectives. One of
the known problems in this context is data logistics, which refers to the process of managing
the data flow within a federation, including its collection, storage, transmission, analysis, and
security. To address this issue, we propose an approach of Ephemeral Buffers (EB) inspired
from the concepts of Cybercosm [3] and the Hourglass model [4].
We assume a workflow representation such as, but not restricted to, the Common Workflow
Language (CWL) [6]. Data logistics computation follows the workflow’s task allocations to the
infrastructures (HPC centers, data centers, Cloud, etc.). It decides origin-destination of the data
transfers and when to perform them. This process can be iteratively applied to optimize the
workflow orchestration.
EBs are designed to be a straightforward and lightweight data transfer mechanism for data
staging, data retrieval, and dynamic buffer allocation. Following the Hourglass model prin-
ciples, they are designed to make them easy to deploy across the continuum with minimal
cybersecurity risks. In [5], a similar approach is used, but EBs are extended to cross-facilities
deployment. EBs are defined by the following key properties: system-dependent maximum
size, time-limited availability, finite availability, a Unique IDentifier (UID), a set of mandatory
metadata and minimized access right.
In this presentation we will show how EBs can be used to deploy the radio astronomy data
processing tool, DDF Pipeline [8, 9]. DDF Pipeline is developed to address the challenge of
the SKA [7] next generation radio telescope that faces unprecedented, massive data processing
issues. We present an implementation of the approach on the national computing infrastruc-
ture of GENCI [2], the French national agency that gathers supercomputing facilities and data
centers from the SKA communities.

### Auteurs

- Mathis Certenais (Université de Rennes)
- Francois Bodin (Université de Rennes)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #22

### Titre

Robust and Efficient Task Allocation in Large-Scale Distributed Systems: Bridging Theory and Practice

### Résumé

Task allocation is a fundamental problem in distributed computing, requiring an efficient and dynamic assignment of tasks to computational processes over time. In large-scale cloud-based infrastructures, real-world task allocation systems face challenges such as fluctuating resource availability, numerous failures, and user-driven task cancellations. Ensuring both correctness and robustness while achieving high performance at scale remains a critical requirement for industrial applications.  

Our research aims to develop a methodology for specifying, verifying and implementing distributed task allocation algorithms that bridge the gap between theoretical models and practical deployment. We demonstrate this approach through extensive cloud-based experiments leveraging ArmoniK, an industrial-grade open-source framework for executing dynamic task graphs on fault-prone elastic infrastructures. 

This research forms the foundation of an ongoing  PhD thesis. This presentation provides an overview of the problem space and a roadmap for future work.

### Auteurs

- Quentin Delamea (LISN, Aneo)
- Janna Burman (LISN)
- Jérôme Gurhem (Aneo)
- Stéphane Vialle (LISN, CentraleSupélec)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #23

### Titre

Architecting Value Prediction around In-Order Prediction

### Résumé

In the search for performance, in-order execution cannot expect to prevail as older long latency instructions prevent younger ones from issuing. Although stall-on-use processors allow independent instructions to issue in the shadow of a cache miss, the compiler cannot always find enough independent work to keep pipeline resources busy. In this paper, we study how both value prediction based on address prediction and direct value prediction can be built into an in-order pipeline to unlock significant performance. We further show that the in-order execution property provides advantages in that the pipeline may speculate aggressively without suffering from any recovery penalty. Finally, we combine this data speculation infrastructure with a reworked cache hierarchy that relies on a fast first level cache that can be written speculatively. We  show that such an in-order pipeline can reach a performance level that is comparable to an equally -- although moderately -- wide  out-of-order processor, without requiring support for partial out-of-order execution such as out-of-order memory hazard handling or full-fledged register renaming.
Overall, we increase the performance of a 32-entry scoreboard, 4-issue in-order processor based on a scaled up Open Hardware Group CVA6 by 38.4% (geomean), achieving 86.7% and 46.3%  of the gains brought by comparable out-of-order processors featuring 32/16-entry and 64/32-entry Reorder Buffer and scheduler, respectively

### Auteurs

- Pierre Ravenel (TIMA / Kalray)
- Arthur Perais (TIMA / CNRS)
- Frédéric Pétrot (TIMA / GINP)
- Benoît Dupont de Dinechin (Kalray)

### Sujet

- Architecture

### Type de présentation

Présentation sans poster

---

## Soumission #26

### Titre

Simuler rocHPL pour prédire la performance des supercalculateurs

### Résumé

Le HPL est le benchmark le plus couramment utilisé pour évaluer les
  performances des supercalculateurs. En phase de
  conception et de dimensionnement de très grands clusters, il est
  donc primordial de prédire la performance du HPL pour des
  architectures matérielles hétérogènes (CPU/GPU) et un réseau
  d'interconnexion optimisé.
  
  Dans ce cadre, la bibliothèque logicielle SimGrid
  apporte un des éléments de réponse (simulation du réseau). Par
  exemple, Tom Cornebize, lors de sa thèse, a ainsi
  pu émuler la version CPU de référence du HPL.
  
  Cependant, les supercalculateurs les plus puissants et les plus
  efficaces sont basés sur des noeuds de calcul CPU/GPU, pour lesquels
  les constructeurs proposent des implémentations optimisées telles
  que le rocHPL pour les GPU AMD.


  Notre approche repose sur une simulation à gros grains du rocHPL combinant
  une reconstruction haut-niveau de l'algorithme, des modèles de
  performance pour les noyaux de calcul (BLAS), et SimGrid pour la
  simulation des communications.
  
  Nous avons validé notre méthodologie et le simulateur par une série
  de comparaisons entre exécutions réelles et simulées.
  
  Des optimisations ont permis de réduire le coût des simulations à
  grande échelle, ce qui permet de restituer les performances des
  plus grands systèmes AMD du TOP500. Cette approche vise à être
  étendue à des applications de calcul différentes du HPL et sur des
  architectures matérielles autres que AMD.

### Auteurs

- Jean Conan (EVIDEN, Univ. Bordeaux, Inria, LaBRI)
- Abdou Germouche (Univ. Bordeaux, Inria, LaBRI)
- Arnaud Legrand (Univ. Grenoble Alpes, CNRS, Inria, Grenoble INP, LIG)
- Louis Poirel (EVIDEN)

### Sujet

- Parallélisme
- Système

### Type de présentation

Présentation avec poster

---

## Soumission #27

### Titre

ATOMEC : Quand les mobiles deviennent le moteur du Edge Computing

### Résumé

L’essor des dispositifs mobiles connectés – qu’il s’agisse de smartphones, de véhicules intelligents, de montres connectées ou d’autres objets communicants – ouvre de nouvelles perspectives pour l’infrastructure réseau. Traditionnellement sous-exploités, ces appareils disposent pourtant de ressources de calcul, de stockage et d’énergie qui pourraient renforcer le Multi-Access Edge Computing (MEC).

Nous explorons ainsi une approche innovante visant à étendre la capacité du MEC en tirant parti des ressources disponibles des dispositifs mobiles au-delà de la bordure réseau. L’objectif est d’optimiser l’allocation des tâches en identifiant les appareils capables de traiter des calculs de manière distribuée, tout en tenant compte des contraintes liées à leur mobilité et à la fluctuation de leurs ressources. Pour exploiter efficacement ces nœuds mobiles, le MEC doit être capable d’évaluer dynamiquement son environnement, notamment la disponibilité des ressources, les capacités de calcul, le stockage et l’autonomie énergétique.

Nous proposons ATOMEC (Adaptive Task Offloading for Mobile Edge Computing), un algorithme basé sur l’intelligence artificielle, conçu pour optimiser la sélection des nœuds et l’affectation des tâches en fonction de plusieurs paramètres. Notre approche repose sur deux axes principaux : un algorithme de classification permettant d’identifier avec précision les dispositifs connectés tels que les drones, les smartphones et les voitures grâce à des techniques avancées d’apprentissage automatique, afin d’évaluer leurs caractéristiques et leurs ressources de calcul, ainsi qu’un algorithme décisionnel chargé d’orchestrer efficacement le déchargement des tâches pour assurer une répartition optimale de la charge de travail.

Cette approche vise à renforcer la flexibilité et la puissance de calcul du MEC à grande échelle, tout en garantissant une gestion dynamique et optimale des ressources mobiles inexploitées.

### Auteurs

- Sadia Khizar ("None")
- Antoine Mallet

### Sujet

- Architecture
- Système

### Type de présentation

Présentation avec poster

---

## Soumission #28

### Titre

Distribution de l’électronique de contrôle des Qubits dans et en dehors du cryostat

### Résumé

Les ordinateurs quantiques promettent une accélération exponentielle de certains algorithmes
combinatoires par rapport aux ordinateurs classiques, ce qui permettrait la résolution de problèmes
inatteignables par un ordinateur classique. Un calculateur quantique opère sur des qubits,
un dispositif qui peut être dans un état superposé et intriqué avec d’autres qubits. Il est
généralement accepté qu’un ordinateur quantique utile devra intégrer au moins un million de
qubits physiques, compte-tenu des erreurs inhérentes à leur manipulation.

Un qubit nécessite environ une dizaine de signaux de contrôle. Il n’est donc pas envisageable
que chaque qubit ait ses propres fils de contrôle et lecture sortant du cryostat. En effet, cela
entraînerait des contraintes mécaniques, des pertes de refroidissement par conduction ainsi
que de la latence dans le contrôle. Une solution pour réduire le nombre fils est de passer tout
ou partie de l’électronique de contrôle à froid, auprès des qubits. Cependant, cela rajoute des
contraintes de consommation et de volume de l’électronique de contrôle.

La tendance dans les propositions architecturales récentes est de déplacer les fonctions analogiques
(DAC, amplification) à froid. Cette approche a l’avantage de réduire le bruit, notamment
thermique, mais ne réduit pas nécessairement le nombre de fils entrant dans le cryostat. Pour
ce faire, des méthodes de multiplexage ont été développées, mais ces méthodes permettent de
réduire le nombre de fils seulement d’un ordre de grandeur, ce qui reste incompatible avec un
ordinateur quantique à un million de qubits.

Intel et Google ont expérimenté de déplacer la majorité de leur électronique à froid. Leurs
architectures ne passent cependant pas à l’échelle, car leur consommation est mille fois trop
élevée pour pouvoir mettre un million de qubits dans un cryostat. Si on déplace une partie de
cette électronique à des températures plus élevées dans le cryostat, i.e. des étages différents,
elle devient plus simple à refroidir. Nous proposons donc une approche holistique permettant
d’évaluer le placement approprié des fonctions numériques et analogiques de contrôle des
Qubits "solides" dans et en dehors du cryostat. Ceci nous permettra également d’explorer des
approches alternatives de contrôle des Qubits.

### Auteurs

- Gabriel Zerbib (CEA Grenoble)

### Sujet

- Architecture

### Type de présentation

Présentation avec poster

---

## Soumission #29

### Titre

Kicking the Firmware Out of the TCB with the Miralis Virtual Firmware Monitor

### Résumé

The role of firmware has evolved over the past decades. Not only is firmware responsible for discovering, initializing, and monitoring the system’s chipset, board, and devices, but it also acts as the root of trust and plays a leading role in confidential computing. Yet vulnerabilities in the non-security critical part of the firmware have repeatedly led to the compromise of the core TCB of the system

We propose an alternative architecture that excludes the non-security critical part of the firmware from the TCB by isolating it within a virtual machine with the introduction of a simple and verifiable virtual firmware monitor.

We present the design of Miralis, the first virtual firmware monitor. Miralis can successfully boot Linux with a virtualized, unmodified OpenSBI firmware on multiple RISC-V boards. We demonstrate by construction that the M-mode of the RISC-V architecture meets the Popek & Golberg criteria for classical virtualization, but ARM's EL3 does not. To enhance security, we prove the correctness of major Miralis' subsystems through lightweight formal methods. Finally, our experiments shows that Miralis can be deployed on existing RISC-V hardware, with unmodified, vendor-provided firmawre blobs and with no performance penalty. Further, we demonstrate the creation of enclaves and confidential VMs that exclude the firmware from their TCB.

### Auteurs

- Charly Castes (EPFL)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #30

### Titre

Pallas: : Un format de trace générique pour des analyses performantes

### Résumé

Il est difficile d’identifier la ou les sources des problèmes de performances pour les applications
parallèles. En effet, ces problèmes peuvent venir d’une variété de composants de l’application,
et nécessitent donc l’analyse de plusieurs systèmes. Les problèmes de performances peuvent
se manifester de plusieurs manières et avoir une grande variété de cause : par exemple, un
déséquilibrage de charge de calcul peut être la source de longs temps d’attente dans MPI, ou
des problèmes d’accés concurrents à des ressources peuvent dégrader les performances des
opérations d’I/O.
La détection d’un problème de performance passe par l’analyse de l’exécution d’une applica-
tion, et l’utilisation de plusieurs outils et techniques d’analyse de performance. Pour éviter de
faire de multiples exécutions longues et coûteuses, des outils de tracages sont utilisés. Ils col-
lectent des informations décrivant le comportement de l’application, qu’ils regroupent ensuite
dans ce que l’on appelle une trace. Cette trace peut ensuite être analysée après l’exécution.
Cependant, la génération et l’utilisation de trace peut poser plusieurs problèmes. La généra-
tion de la trace peut changer le comportement de l’application, et ainsi changer les analyses.
De plus, les traces peuvent être composées de milliers de fichiers lourds, surtout pour des ap-
plications utilisant plusieurs milliers de processus. Pour ces applications à grande échelles, les
traces existant actuellement deviennent ainsi peut pratique à utiliser, à cause de leur taille et de
leur temps d’analyse.
Nous proposons un nouveau format de trace, nommé PALLAS. Il s’agit d’un format générique
conçu pour faciliter et accélérer les analyses d’applications à grand échelles. Pendant l’exécu-
tion de l’application, les évènements collectés par PALLASvont être regroupé, et leurs répéti-
tions détectées. Lors de l’écriture sur le disque, PALLASva regrouper les données d’évènements
similaires ensemble, ce qui permet de lire ces traces partiellement de manière très efficace. Cette
détection des répétions de PALLASne dégrade pas significativement la performance des appli-
cations. De plus, les analyses réalisées sur le format PALLASsont plus rapides que des analyses
réalisées sur d’autres formats de trace.
Enfin, nous proposons une API Python permettant de rendre la recherche de problèmes de
performances plus interactive, permettant de charger des traces de plusieurs dizaines de Go en
quelques secondes sur un ordinateur classique. Nous espérons que cette interactivité permet
à un utilisateur de trouver des problèmes de performance plus facilement et plus rapidement
qu’avec les formats de trace existant déjà actuellement.

### Auteurs

- Catherine Guelque (Télécom SudParis)
- Valentin Honoré (ENSIEE)
- François Trahay (Télécom SudParis)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #31

### Titre

Scaling the SOO Global Blackbox Optimizer on a 128-core Architecture

### Résumé

Blackbox optimization refers to the situation where no analytical knowledge about the problem is available beforehand, which is the case in a number of application fields, e.g., multi-disciplinary design, simulation optimization.
In this context, the so-called Simultaneous Optimistic Optimization (SOO) algorithm is a deterministic tree-based global optimizer exposing theoretically provable performance guarantees under mild conditions.
SOO handles the search space as a tree. Each node of the tree corresponds to some region of the search space. A leaf of the tree can be split into smaller cells covering the same original space. Since the root of the tree is the whole search space, the leaves of the tree represent a partition of the space.

We consider the efficient shared-memory parallelization of SOO on a high-end HPC architecture with dozens of CPU cores. We propose different strategies based on eliciting the possible levels of parallelism underlying the SOO algorithm.
We first use a naive approach, performing multiple evaluations of the blackbox function in parallel.
Even with some improvements regarding parallel memory allocations and parallel tree manipulation operations, this version does not scale with the number of cores.
We then leverage a second, less obvious, parallelism level to fully parallelize SOO based on its tree traversals, and allow the threads to swap their traversals in parallel so as to increase parallel efficiency. By contrast, this version is able to provide substantial improvements in terms of scalability and performance.

We validate our strategies with a detailed performance analysis on a compute server with two 64-core processors, using a number of diverse benchmark functions with both increasing dimensions and number of cores. The traversal-based version can offer (in average over the experimented functions) a 3.2× performance gain over the evaluation-based version. The traversal-based version can also benefit from the SMT feature of the CPU cores, providing parallel speedups up to 174.8 on 128 cores.

We will also present ongoing work on the extension of these versions to distributed-memory architectures, where we have designed an alternative fully asynchronous version of SOO.

### Auteurs

- David Redon (Univ. Lille, CNRS, Inria, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France)
- Bilel Derbel (Univ. Lille, CNRS, Inria, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France)
- Pierre Fortin (Univ. Lille, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #32

### Titre

Contraintes d’OpenMP pour la parallélisation automatique à base de tâches

### Résumé

Les architectures modernes sont équipées de processeurs multi-cœurs qui nécessitent l’exécu-
tion d’applications parallèles pour être exploitées à pleine puissance. La parallélisation d’un
programme peut être réalisée par des experts en utilisant, par exemple, la programmation ba-
sée sur les tâches. Cela peut aussi être réalisé de façon automatique. Dans cet article, nous abor-
dons la parallélisation automatique basée sur les tâches et son implémentation avec OpenMP.
Notre travail se focalise sur la gestion des dépendances des tableaux et l’évaluation de la pro-
fondeur lors de la création de tâches. Nous analysons différentes méthodes de gestion de ces
aspects et évaluons leur impact en termes de coût supplémentaire. Nos résultats expérimentaux
montrent que l’utilisation des itérateurs et de la clause if d’OpenMP entraîne un coût significa-
tif. Nous identifions des alternatives plus efficaces qui permettent d’optimiser la performance
des exécutions parallèles.

### Auteurs

- Julien Gaupp (Inria CAMUS)
- Berenger Bramas (Inria CAMUS)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #33

### Titre

Portage sur GPU du calcul des forces internes d'un code basé sur la méthode des éléments finis spectraux

### Résumé

La méthode des éléments finis spectraux est utilisée dans de nombreux codes de simulations. Ces codes sont très exigeants en terme de calculs et nécessitent donc d'être parallélisés. Dans le cadre de la simulation de la propagation d'ondes sismiques, nous proposons de faciliter la parallélisation sur GPU du cœur de cette méthode en s’appuyant sur une approche existante vectorisée sur CPU. L’attention est portée sur l’utilisation de la mémoire partagée et les éventuels conflits d’accès. La méthode proposée pour le portage sur GPU permet d'obtenir un speedup de 7.7 par rapport à la version vectorisée sur CPU utilisant un cœur.

### Auteurs

- Tom Budon (Université d'Orléans)
- Emmanuel Melin (Université d'Orléans)
- Sébastien Limet (Université d'Orléans)
- Florent de Martin (BRGM)
- Sylvain Jubertie (Intel)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #34

### Titre

Improving energy efficiency of HPC applications using unbalanced GPU power capping

### Résumé

Energy efficiency represents a significant challenge in the domain of high-performance computing (HPC).  One potential key parameter to improve energy efficiency is the use of power capping, a technique for controlling the power limits of a device, such as a CPU or GPU. In this paper, we propose to examine the impact of GPU power capping in the context of HPC applications using heterogeneous computing systems. To this end, we first conduct an extensive study of the impact of GPU power capping on a compute intensive kernel, namely matrix multiplication kernel (GEMM), on different Nvidia GPU architectures. Interestingly, such compute-intensive kernels are up to 30% more energy efficient when the GPU is set to 55-70% of its Thermal Design Power (TDP). Using the best power capping configuration provided by this study, we investigate how setting different power caps for GPU devices of a heterogeneous computing node can improve the energy efficiency of the running application. We consider dense linear algebra task-based operations, namely matrix multiplication and Cholesky factorization. We show how the underlying runtime system scheduler can then automatically adapt its decisions to take advantage of the heterogeneous performance capability of each GPU.  The results show that for a given platform equipped with four GPU devices, applying a power cap on all GPUs improves the energy efficiency for matrix multiplication up to 24.3% (resp. 33.78%) for double (resp. single) precision.

### Auteurs

- Albert d'Aviau de Piolant (Inria, Université de Bordeaux)
- Hayfa Tayeb (Inria, Université de Strasbourg)
- Berenger Bramas (Inria, Université de Strasbourg)
- Mathieu Faverge (Inria, Bordeaux INP)
- Abdou Guermouche (Inria, Université de Bordeaux)
- Amina Guermouche (Inria, Bordeaux INP)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #35

### Titre

Compression en virgule flottante appliquée aux H-Matrices

### Résumé

L’algèbre des H-Matrices possède de nombreux avantages pour la résolution de système li-
néaires, que ce soit en termes de stabilité numérique ou de temps de calcul comparé à des
solveurs directs ou itératifs plus classiques, mais présente toutefois une limitation sur la taille
des problèmes. En effet, que ce soit en terme de coût spatial (occupation mémoire trop
importante) ou de coût temporel (calculs limités par la bande passante mémoire), réduire la
taille mémoire des matrices utilisées est un enjeu majeur. De plus, cela permet d’alléger le sto-
ckage sur disque pour les cas de calculs dits "out-of-core" ainsi que de diminuer le poids des
communications, élément déterminant notamment lors des calculs sur architecture à mémoire
distribuée. Dans cette optique, et dans le cadre de cette thèse, nous nous intéressons à la com-
pression en virgule flottante des différents blocs d’une H-Matrice dans un contexte industriel
afin de réduire l’empreinte mémoire lors des calculs pour un gain en espace et en temps, et ce
avec une perte de précision contrôlée. Pour cela, plusieurs schémas de compression arith-
métique sont envisagés et comparés, afin de déterminer ceux qui permettent les meilleurs taux
de compression à une précision donnée. Des premiers tests seront effectués sur une version
séquentielle de la librairie H-Matrice, avec comme objectif à terme d’intégrer cette compres-
sion dans une version parallèle du code. Cela permettrait ainsi de traiter des problèmes de
plus grande taille (et donc avec une modélisation plus fine et plus précise) ou des problèmes
de même taille avec un coût spatial et temporel réduit.

### Auteurs

- Clément Peaucelle (Equipe CONCACE - Airbus, INRIA, Cerfacs)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #36

### Titre

Generic Tiled Layouts for High-Performance Multidimensional Data Structures

### Résumé

Performance optimization strategies for exascale-class HPC applications primarily rely on fine-tuning implementations, requiring comprehensive knowledge of today's heterogeneous hardware architectures. While existing programming models provide abstractions of algorithmic optimizations, they overlook the potential of improving the memory layout of data structures.
In this paper, we introduce generic tiled layouts for multidimensional data structures, designed to work seamlessly with C++23's std::mdspan. Experimental results on a naive dense matrix multiplication demonstrate that, by replacing standard layouts with our proposed solution, we achieve an average speedup of over 2.2x, with peak performance improvements of up to 6.7x.

### Auteurs

- Gabriel Dos Santos (CEA)
- Cédric Chevalier (CEA)
- Hugo Taboada (CEA)
- Marc Pérache (CEA)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #37

### Titre

Facilitating heterogeneity management on the computing continuum

### Résumé

The computing continuum combines edge and cloud computing resources to create a seamless infrastructure.
This introduces resource heterogeneity.  
Therefore, meeting application requirements such as fast response times, high-quality results, detailed data, low costs, and energy efficiency becomes challenging.
We suggest using self-adaptive systems and software variability management methods to manage this complexity.
Specifically, we propose modeling software variability and infrastructure heterogeneity to help configure and deploy systems effectively.
We illustrate this approach with a video analytics use case.

### Auteurs

- Martin MOLLI (IMT Atlantique, Inria, LS2N, UMR CNRS 6004, F-44307 Nantes, France)
- Daniel Balouek (IMT Atlantique, Inria, LS2N, UMR CNRS 6004, F-44307 Nantes, France)
- Paul Temple (University of Rennes, CNRS, Inria, IRISA)
- Thomas Ledoux (IMT Atlantique, Inria, LS2N, UMR CNRS 6004, F-44307 Nantes, France)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #38

### Titre

Coarse-grain Congestion Regulation Using Control Theory

### Résumé

Efficient data access in High-Performance Computing (HPC) systems is essential to the perfor-mance of intensive computing tasks. Traditional optimizations of the I/O stack aim to improvepeak performance but are often workload specific and require deep expertise, making them dif-ficult to generalize. In shared HPC environments, resource congestion can lead to unpredictableperformance, causing slowdowns and timeouts. To address these challenges, a self-adaptiveapproach based on Control Theory is proposed to dynamically regulate client-side I/O rates.By using few run-time system load metrics, the approach aims to reduce congestion and im-prove performance stability. We implement a controller on a single node system as a prelimi-nary work, and obtain encouraging results for addressing a multi-node cluster in future works.

### Auteurs

- Thomas Collignon (Qarnot Computing, F-92120 Montrouge, France / Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France)
- Kouds Halitim (Univ. Grenoble Alpes, Inria, CNRS, LIG, F-38000 Grenoble, France)
- Raphaël Bleuse (Univ. Grenoble Alpes, Inria, CNRS, LIG, F-38000 Grenoble, France)
- Sophie Cerf (Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France)
- Bogdan Robu (Univ. Grenoble Alpes, CNRS, Grenoble INP, GIPSA-lab, F-38000 Grenoble, France)
- Eric Rutten (Univ. Grenoble Alpes, Inria, CNRS, LIG, F-38000 Grenoble, France)
- Lionel Seinturier (Univ. Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France)
- Alexandre Van Kempen (Qarnot Computing, F-92120 Montrouge, France)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #39

### Titre

An analysis for the design of an efficient replica management strategy

### Résumé

The transition from centralized systems to geo-distributed infrastructures offers increased flexibility by enabling the use of geographically distributed resources. These infrastructures are employed in fields requiring significant processing capabilities, such as scientific research. However, data management, which is an important aspect of efficiently managing geo-distributed infrastructure and achieving optimal performance, is difficult to implement due to various constraints (hardware and software constraints). In addition, energy consumption has become a crucial factor to consider in modern infrastructures. In this work, we focus on replication, which is a common approach in data management, but, it is important to understand that naive replication can lead to costly transfers and resource loses. The success of a replication policy relies on a balance between performance, availability, and data transfer optimization. Build on this, we present a preliminary study aimed at minimizing transfers, especially by looking for an efficient number of replicas, while ensuring optimal performance. Through this study, we have shown that by focusing only on important transfers, it is possible to achieve good performance while reducing energy costs.

### Auteurs

- Cherif SI MOHAMMED (ADEME, LS2N, IMT Atlantique Nantes.)
- Adrien LEBRE (INRIA, LS2N, IMT Atlantique Nantes.)
- Alexandre VAN KEMPEN (Qarnot Computing)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #40

### Titre

AndroWatts : Unpacking the Power Consumption of Mobile Device’s Components

### Résumé

Ces dernières années, l’intérêt pour la mesure de la consommation des appareils mobiles n’a
fait que grandir, principalement lié aux limites imposées par les batteries : celles-ci ont une
durée de vie limitée ainsi qu’un coût environnemental important tout au long de leur cycle de
vie.
Malheureusement, les solutions proposées pour mesurer la consommation d’une application
manquent de précision. Elles reposent en général sur la mesure de la batterie uniquement,
parfois accompagnée des mesures de certains composants. Il est donc nécessaire de fournir
aux développeurs de nouvelles options pour quantifier et surveiller la consommation de leurs
applications afin d’y apporter des optimisations pertinentes.
Avec cet objectif, nous proposons une nouvelle méthode pour estimer cette consommation.
Plutôt que de s’appuyer sur la décharge de la batterie directement, nous modélisons la consom-
mation des composants du téléphone afin de déterminer leurs impacts sur la décharge de l’ap-
pareil au cours de l’exécution d’une application.
Dans ce papier, nous (i) modélisons la consommation d’une application en utilisant une com-
binaison des métriques fournies par Android et le téléphone, et (ii) évaluons la précision d’une
stratégie basée sur la consommation par composant, ainsi que (iii) l’impact de la quantité de
données nécessaires pour notre modèle. Nos expérimentations nous permettent de constater
une grande précision de nos modèles linéaires ainsi qu’une forte corrélation entre les valeurs
de consommations prédites et constatées, notamment pour le CPU et le GPU.

### Auteurs

- Noé Chachignot (Centre Inria de l’Université de Lille)
- Édouard Guégain (Greenspector)
- Rémy Raes (Centre Inria de l’Université de Lille)
- Clément Quinton (Université de Lille)
- Romain Rouvoy (Université de Lille)

### Sujet

- Système

### Type de présentation

Présentation avec poster

---

## Soumission #41

### Titre

Anticipation des communications réseau grâce à la connaissance du futur dans le parallélisme à tâches

### Résumé

Les architectures actuelles des calculateurs haute performance présentent des nœuds multi-cœurs ou GPU reliés par un réseau haute performance. Ce type d'architecture pousse à l'utilisation de modèles de programmation parallèle hybride multi-thread et distribuée. Par ailleurs, sur certains de ces réseaux haute-performance, une étape préalable à l'échange de données est l'enregistrement mémoire qui permet à la carte réseau d'accéder directement aux adresses mémoire enregistrées sans passer par l'OS. Or cette étape allonge la durée des communications car elle est réalisée juste avant l'envoi ou réception de données. Par conséquent, une pratique commune est de réaliser un cache d'enregistrement appelé rcache. Cependant, certaines applications utilisent des buffers de communications systématiquement différents et n'en bénéficient donc pas. Ainsi, notre objectif est de réaliser l'enregistrement mémoire plus tôt, ce qui est possible car cette étape n'utilise que les adresses mémoire et peut donc être réalisée avant que les contenus des buffers de réception ou d'envoi ne soient prêts. 

Pour y parvenir, nous souhaitons mettre à profit l'utilisation des modèles de programmation parallèle hybride comme StarPU, qui est un système d'exécution s'appuyant sur un parallélisme à base de tâches. Dans sa version distribuée, StarPU s'appuie sur une bibliothèque MPI, ou bien sur NewMadeleine, et exécute les communications inter-nœuds de manière implicite en les inférant depuis le graphe de tâches. Ainsi, en utilisant la connaissance du futur fournie par le graphe de tâche maintenu par StarPU, il est possible d'être prévenu lorsque la dernière tâche de calcul utilisant un buffer d'envoi ou de réception commence. De cette manière, nous pouvons réaliser l'enregistrement mémoire pendant l'exécution de cette tâche, et éviter la latence induite par cette étape. En retirant la phase d'enregistrement mémoire du chemin critique de l'exécution des communications nous espérons réduire la durée des communications réseau, ce qui devraient conduire à de meilleures performances des applications distribuées utilisant StarPU.

### Auteurs

- Tanguy Chatelain (ENSEIRB-MATMECA / Centre Inria de l'Université de Bordeaux)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #42

### Titre

Sufficiency in Cloud : Minimizing Idle Power Consumption Through Improved User Behavior

### Résumé

Cloud computing enables scalable and flexible resource allocation. However, it often leads to unnecessary energy consumption due to inefficient user behaviors and resource provisioning strategies. This research explores sufficiency techniques in cloud environments and aims to reduce energy waste by encouraging both cloud users and providers to adopt more conscious resource usage practices.

 We propose that simple user-driven optimizations can lead to significant energy reductions. To find the possible optimization techniques, we analyze job records from the Grid'5000 testbed. We investigate resource usage both during idle times and under utilization, and measure their impact on energy consumption. User behavior improvements could include selecting appropriate resources for workloads and actively managing idle periods. Our contribution focus on understanding resource usage patterns and ensuring that only the required resources are allocated. 
    
To demonstrate how small adjustments in user practices can contribute to sustainability in cloud computing, we simulate these behavior changes and assess their impact on the overall idle consumption of the system. Using the  simulation platform Batsim, we evaluate the potential energy savings when users adjust their behaviors. To achieve this, we perform simulations with original and modified workloads, and compare the results.

This study aims to bridge the gap between energy-efficient cloud management and user awareness. We believe that intentional sufficiency techniques rather than just technological advancements can drive substantial reductions in cloud energy consumption.

### Auteurs

- Eyvaz Ahmadzada (Institut de Recherche en Informatique de Toulouse - IRIT)
- Patricia Stolf (Institut de Recherche en Informatique de Toulouse - IRIT)
- Jean-Marc Pierson (Institut de Recherche en Informatique de Toulouse - IRIT)
- Laurent Lefèvre (ENS de Lyon - École normale supérieure de Lyon)

### Sujet

- Architecture
- Système

### Type de présentation

Présentation sans poster

---

## Soumission #43

### Titre

Flexible Performance Anomaly Detection in Microservice Applications with ctl-SRNN

### Résumé

Detecting performance anomalies in microservice applications is challenging because the services composing such applications are highly diverse and frequently updated. Machine learning approaches capable of automatically detecting performance anomalies are highly desirable but often difficult to use in practice, particularly if they require labeled data, significant training time, or predefined thresholds to distinguish normal from abnormal behavior. This paper presents ctl-SRNN, a generative probabilistic model designed to detect performance anomalies in microservice applications. The ctl-SRNN model benefits of a control variable to give contextual information on service workload while incorporating uncertainty quantification to dynamically define normal behavior of its resource usage. Experiments conducted using two microservice applications, realistic workloads, and various types of anomalies demonstrate that ctl-SRNN achieves an improvement of more than 50% in anomaly detection accuracy compared to state-of-the-art approaches. Furthermore, results show that it is the combination of an probabilistic model with a control variable and uncertainty quantification that improves anomaly detection.

### Auteurs

- Gabriel Grabher (Université Grenoble-Alpes)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #44

### Titre

La Quête du Scheduling Parfait : Jouer sur Tous les Tableaux

### Résumé

Ces dernières années, les innovations dans l'utilisation de centres de données et la popularité de nouveaux services tels que l'apprentissage profond ont permis d'obtenir des avancées importantes dans de nombreux domaines comme la santé, l'éducation ou encore le commerce. Ces progrès vont avec une consommation d'énergie toujours plus importante, malgré de nombreux gains d'efficacité, tandis qu'il faudrait maîtriser notre consommation d'énergie dans un contexte de crise climatique. Nous avons identifié un potentiel de réduction d'énergie grâce à des techniques de déplacement de charges informatiques sur des serveurs qui modifient le moment d'exécution, le lieu ou encore qui adaptent le processus d'exécution par une alternative pour un résultat similaire.

Dans ce papier, nous explorons la possibilité de combiner ces différentes techniques, et évaluons les impacts de ces techniques combinées. A l'aide du simulateur Batsim, nous avons développé une méthodologie pour évaluer l'efficacité de techniques combinées sur des ensembles de tâches générées artificiellement.

### Auteurs

- Nicolas Tirel (Université de Pau et des Pays de l'Adour)
- Philippe Roose (Université de Pau et des Pays de l'Adour)
- Sergio Ilarri (Universidad de Zaragoza (UNIZAR))
- Olivier Le Goaër (Université de Pau et des Pays de l'Adour)
- Adel Noureddine (Université de Pau et des Pays de l'Adour)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #45

### Titre

Traitement de données en temps réel pour les systèmes embarqués communicants : l’adéquation algorithme-architecture à la rescousse

### Résumé

Les systèmes embarqués modernes nécessitent fréquemment le transfert rapide de grandes quantités de données vers des processeurs à capacité mémoire limitée, notamment dans des domaines comme le traitement radar, l'imagerie ou l'intelligence artificielle embarquée. Dans ce contexte, le traitement et la vérification de l'intégrité des données, via un calcul en temps réel du CRC (Cyclic Redundancy Check) par exemple, représente un véritable défi, notamment en raison des contraintes temporelles. En effet, cela demande au système d'être capable de récupérer une donnée, la sauvegarder au bon emplacement et de calculer un CRC cumulatif avant de recevoir une nouvelle donnée, pour éviter une perte d'information. Les solutions traditionnelles requièrent typiquement de multiples domaines d'horloge et une fréquence CPU supérieure à celle de la communication, complexifiant ainsi le système et augmentant la consommation énergétique.

Ce travail propose de faire fonctionner le processeur à la fréquence de communication du SPI, supprimant ainsi le besoin de multiples domaines d'horloges. Cette approche simplifie la conception matérielle, mais apporte de fortes contraintes en termes de temps d'exécution.
Une méthodologie basée sur l'adéquation algorithme-architecture (AAA) permet cependant de garantir un traitement en temps réel, malgré un nombre de cycles d'horloges très limités pour l'exécution du traitement.
L'utilisation de coprocesseurs et de périphériques dédiés intégrés dans une architecture ouverte RISC-V permet d'accélérer les calculs tout en minimisant le nombre d'instructions exécutées par le CPU. Pour atteindre les performances souhaitées, une série de stratégies d'optimisations logicielles ont été mises en place. Ceci inclus des opérations SIMD (Single Instruction on Multiple Data), le déroulement des boucles et la suppression d'instructions redondantes ou inutiles grâce à une analyse au niveau assembleur. 

Les résultats expérimentaux sur FPGA et ASIC montrent qu'une approche combinée matériel-logiciel permet de respecter strictement les contraintes de temps réel, atteignant un traitement effectif d'un octet reçu (8 bits) en moins de 8 cycles d'horloge. Ces résultats ont été valorisés lors de la conférence ICECS en novembre 2024 et le code source est ouvert et accessible en ligne. À terme, la méthodologie proposée rend possible le remplacement d'ASIC existants par des architectures programmables, tout en conservant une compatibilité broche-à-broche avec les systèmes existants.

### Auteurs

- Jonathan Saussereau (IMS Bordeaux)
- Christophe Jego (IMS Bordeaux)
- Camille Leroux (IMS Bordeaux)
- Jean-Baptiste Begueret (IMS Bordeaux)

### Sujet

- Architecture

### Type de présentation

Présentation sans poster

---

## Soumission #46

### Titre

Partitionnement hiérarchique de graphe pour la compression H-matrice

### Résumé

La méthode des éléments finis de frontière (Boundary Element Method ou BEM) présente de nombreux avantages pour la simulation de phénomènes complexes. En plaçant les inconnues du problème (ou degrés de liberté) sur des frontières entre différents milieux, il devient possible de modéliser des problèmes avec des conditions limites lointaines (écoulements d’un fluide autour d’un objet, diffraction d’une onde acoustique ou électromagnétique, transferts thermiques par rayonnement, ...). En contrepartie, les degrés de liberté se trouvent couplés et la matrice représentative du système devient dense. Lorsque cette matrice dense peut être décomposée en sous-blocs de rang faible, il est possible de construire une matrice hiérarchique (H-matrice) approchant le système à une précision choisie. Dans les cas les plus favorables, cette approximation permet de réduire la complexité spatiale de O(n^2) à O(n log(n)) en compressant les sous-blocs de la matrice initiale. Ce travail explore le lien entre le partitionnement des degrés de liberté et le taux de compression de la H-matrice. Une nouvelle technique de partitionnement hiérarchique, conçue pour optimiser la compression H-matrice, est également présentée.  Contrairement à des algorithmes exploitant la géométrie du problème (Median cut, Cobblestone ou Space-filling curves), cette nouvelle méthode repose sur l’utilisation d’un graphe de connectivité des degrés de liberté. Ce graphe est construit en temps quasi-linéaire (O(n log(n))) à partir du maillage de l’objet étudié et partitionné en temps log-quadratique (O(n^2 log(n))) grâce à un partitionneur multi-niveau. Une contrainte supplémentaire est imposée afin d’équilibrer la charge des partitions, pour des optimisations sur des supports d’exécution à base de tâches.  Des expériences numériques sont réalisées sur un ensemble de cas d’application, issus de simulations en électromagnétisme. Ces cas couvrent différents types de géométries et vont de quelques milliers de degrés de liberté à plus de huit-cent-mille. Le nouvel algorithme est comparé aux méthodes géométriques selon trois critères : le temps de partitionnement, le taux de compression des H-matrices et le temps de factorisation.

### Auteurs

- Dimitri Walther (CEA, Univ. Bordeaux, CNRS, Bordeaux INP, INRIA, LaBRI, UMR 5800, F-33400 Talence, France)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #47

### Titre

Classifieur acoustique multi-sources embarqué pour milieu sous-marin

### Résumé

La reconnaissance des sources acoustiques sous-marines représente un défi majeur en raison de la complexité inhérente à l'environnement marin. Cet environnement est marqué par une diversité des sources sonores d'origine animale ou d'activités humaines, un bruit de fond important et des schémas de propagation sonore non linéaires. Ces facteurs compliquent considérablement la classification précise des sources dans des conditions réelles.

Dans ce poster, nous présentons une approche pour la classification de signaux en acoustique sous-marine (ASM), intégrant l'ensemble de la chaîne de traitement et de classification sur une plateforme matérielle embarquée. Cette approche permet d'effectuer un maximum de traitements in situ tout en minimisant le transfert des données volumineuses. Notre méthode est conçue pour détecter et classifier une large gamme de sources acoustiques sous-marines. Cela inclut les signaux stationnaires, non stationnaires (transitoires et impulsionnels), anthropiques et biologiques.

Nous combinons la fusion de caractéristiques acoustiques multi-niveaux avec un réseau de neurones convolutif résiduel (ResNet), optimisé pour une implémentation embarquée. Cette approche exploite les avantages intrinsèques des FPGA, notamment leur capacité de traitement en temps réel et basse consommation. Elle respecte également les contraintes strictes de faible consommation énergétique et d'efficacité computationnelle.

Les caractéristiques acoustiques sont extraites à l'aide de pré-traitements incluant les MFCC (Mel-frequency cepstrum coefficient), les GFCC (Gammatone frequency cepstral coefficient), le spectre LOFAR (Low-Frequency Analyzer and Recorder) et la CQT (constant Q transform). Ces caractéristiques fusionnées alimentent un modèle CNN résiduel embarqué, utilisé comme classificateur pour l'identification des cibles acoustiques sous-marines. Ce type de système pourrait permettre de transmettre des alertes enrichies d’indicateurs de confiance et d’évaluation des risques.

Les résultats expérimentaux démontrent l'efficacité de cette méthode pour améliorer la précision et la robustesse de la classification dans des environnements sous-marins complexes. Cette approche ouvre de nouvelles perspectives pour des applications avancées en surveillance marine et en exploration autonome.

### Auteurs

- Mohand Hamadouche (Lab-STICC, Université de Bretagne Occidentale (UBO))
- Catherine Dezan (Lab-STICC, Université de Bretagne Occidentale (UBO))
- Erwan Fabiani (Lab-STICC, Université de Bretagne Occidentale (UBO))
- Hélène Pihan-Le Bars (Service Hydrographique et Océanographique de la Marine (SHOM))
- Myriam Lajaunie (Service Hydrographique et Océanographique de la Marine (SHOM))
- David Dellong (Service Hydrographique et Océanographique de la Marine (SHOM))

### Sujet

- Système

### Type de présentation

Présentation avec poster

---

## Soumission #48

### Titre

Implémentation et évaluation de l'algorithme AKAZE en SYCL

### Résumé

Dans cet exposé, on présentera une étude de cas portant sur la programmation parallèle de l'algorithme AKAZE en SYCL, réalisée dans le cadre d'une thèse débutant au sein du laboratoire commun Lab-STICC/Thales-LAS. AKAZE est un algorithme de traitement d'image pour l'extraction de caractéristiques (pixels clefs), qui permet un suivi 2D d'un objet dans un flot vidéo avec une bonne tolérance aux transformations géométriques. En se basant sur une version C++ de référence avec parallélisation openMP pour multicœur, on expliquera la nature des modifications pour le portage en SYCL et on établira une comparaison des performances obtenues sur multicœur. 

Le standard SYCL (du consortium Khronos) est basé sur du C++, est mono-source et met en œuvre la portabilité et l'hétérogénéité, via un modèle normalisé de tâches de calcul (kernels) communiquant par des tampons mémoires, dont le support d'exécution est paramétrable. SYCL vise à devenir un standard industriel, déployable et portable sur toute plateforme de calcul haute performance hétérogène, depuis les supercalculateurs jusqu'aux puces embarquées. Cette capacité est nécessaire pour faciliter la maitrise des différents modèles de calcul sous-jacents et leurs interactions dans une plateforme hétérogène qui combine des architectures de nature différente (multicœur, GPGPU, FPGA). 

La thèse vise à évaluer les apports de la programmation SYCL pour les traitements embarqués spécifiques au domaine métier considéré (traitement du signal, traitement d'image, classification). Elle devra établir des patrons de conception pour les modèles d'architectures considérés et, in fine, développer un environnement d'aide à la conception améliorant la productivité, la portabilité et les performances pour des traitements simulés et leur version embarquée. La problématique de recherche et le contexte des travaux de thèse seront également présentés dans cet exposé. 

Une première partie de ces travaux consiste à évaluer le portage en SYCL de benchmarks significatifs (dont AKAZE) pour le domaine métier. Ces expérimentations combinent de nombreux points de variation à évaluer : environnement de développement SYCL (DPC++ ou adaptiveCPP), constructions parallèles utilisées, support multicœur ou GPGPU, paramètres de la complexité du calcul.

### Auteurs

- Sonia Haddouche (ENSTA/Lab-STICC/Thales LAS)
- Erwan Fabiani (Univ Brest/Lab-STICC)
- Loïc Lagadec (ENSTA/Lab-STICC)
- Franck Danober (Thales LAS)
- Robin Lembach (Thales LAS)
- Christophe Guillet (Thales LAS)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #49

### Titre

Parallélisation automatique à base de tâches avec modélisation de performances

### Résumé

Dans le paradigme de programmation parallèle à base de tâches, un programme est décomposé en tâches liées par des contraintes de dépendance que l'on confie à un moteur d'exécution. Bien que le programmeur se retrouve délesté de certains aspects complexes de la parallélisation, le passage d'un programme séquentiel à un programme parallèle à base de tâches correct et efficace n'est pas trivial. Traditionnellement, la parallélisation automatique cible des nids de boucles. Or, pour de nombreuses applications, la charge de travail est essentiellement concentrée dans certaines fonctions. Une possibilité pour exposer le parallélisme potentiel de ce type d'applications dans un environnement d'exécution à base de tâches, est d'exécuter les fonction coûteuses sous la forme de tâches concurrentes. Cependant cette approche de parallélisation automatique a été moins explorée. Dans [1], nous avons proposé APAC, un traducteur automatique pour réécrire un programme C/C++ séquentiel en un programme parallèle à base de tâches avec des directives OpenMP. Depuis, nous avons formalisé APAC comme une architecture de compilation source-à-source qui s'articule autour d'une représentation intermédiaire que l'on appelle le graphe de candidats de tâches. Dans celui-ci, chaque sommet comprend une ou plusieurs instructions du code source séquentiel. Les dépendances de données entre les instructions se traduisent par des arêtes reliant les sommets correspondants. Des analyses et transformations sur le graphe nous permettent d'identifier les candidats adaptés pour devenir des tâches parallélisables dans le code source résultant et d'y introduire des mécanismes pour contrôler le nombre de tâches et la profondeur du parallélisme à l'exécution. Nous avons également doté APAC d'un module pour modéliser le temps d'exécution des candidats de tâches en fonction de la valeur des arguments des instructions associées. Le but est d'affiner la sélection des candidats adaptés et conditionner la création de tâches à l'exécution. Sur la base d'OptiTrust [2], un cadriciel de transformation de code source, nous avons implémenté un prototype d'APAC capable de traduire un programme séquentiel écrit dans un sous-ensemble de C en un programme parallèle à base de tâches OpenMP. Une étude expérimentale préliminaire nous a permis de valider le prototype et de démontrer l'efficacité des programmes produits sur une sélection de codes sources.

[1] G. Kusoglu, B. Bramas, et S. Genaud, « Automatic task-based parallelization of C++ applications by source-to-source transformations », in Compas 2020 - Conférence francophone en informatique, Lyon, France, juin 2020. [En ligne]. Disponible sur: https://inria.hal.science/hal-02867413

[2] A. Charguéraud, B. Bytyqi, D. Rouhling, et Y. A. Barsamian, « OptiTrust: an Interactive Framework for Source-to-Source Transformations », septembre 2022. [En ligne]. Disponible sur: https://inria.hal.science/hal-03773485

### Auteurs

- Bérenger Bramas (Inria - Strasbourg)
- Marek Felšöci (LiP6 - Paris)
- Stéphane Genaud (ICube - Strasbourg)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #50

### Titre

Fine grain energy measurement in a task based runtime system

### Résumé

Power consumption remains a critical concern for supercomputers. For instance, El Capitan, the world's fastest supercomputer, consumes approximately 29.5 MW of power. Consequently, reducing the energy footprint of high-performance computing (HPC) applications is imperative. A first step toward this goal is monitoring power consumption. Servers may be equipped with wattmeters capable of measuring the power usage of CPUs, memory, and GPUs with a typical measurement period of tens of milliseconds. However, within such intervals, an application may execute hundreds of functions, many of which operate on the microsecond scale. Identifying power-intensive functions within these short execution times remains a significant challenge.

In this work, we leverage the repetitive nature of task-based runtime systems to estimate the power consumption of individual tasks at the microsecond scale. Specifically, we investigate the StarPU task-based runtime system for heterogeneous computing architectures.

To achieve this, we trace application execution while periodically measuring energy consumption via vendor-provided software interfaces. The collected trace includes both energy measurements and task execution data. Post-execution, we map tasks to their respective energy measurement intervals, formulating an overdetermined linear system that correlates tasks with energy consumption. Solving this system allows us to estimate the power consumption of each task idependently from their execution times.

### Auteurs

- Jules Risse (INRIA, Telecom Sudparis)

### Sujet

- Architecture
- Système

### Type de présentation

Présentation avec poster

---

## Soumission #51

### Titre

(Don’t you) Forget about me : de l’importance du temps dans les données

### Résumé

Grâce à leurs multiples capteurs, les smartphones produisent des flux de données de taille conséquente — plusieurs centaines de mégaoctets par jour pour les données de géolocalisation —qui sont difficilement stockables et traitables in situ à cause des capacités limitées des smartphones. De plus, ces séries temporelles recèlent des informations personnelles, telles que les adresses professionnelle et personnelle pour les données de géolocalisation, qui imposent la compression locale des données du smartphone. Les stratégies actuelles de compression de séries temporelles, consistant à supprimer les données les plus anciennes ou à moyenner les données par fenêtre de temps, ne permettent pas de conserver les valeurs aberrantes (outliers) parmi les données, provoquant ainsi une perte d’information.
Dans ce travail, nous proposons une nouvelle technique adaptive de compression de séries temporelles qui (i) conserve les valeurs aberrantes dans les données, (ii) favorise la compression des données les plus anciennes, conservant les données récentes non-compressées, et (iii) permet la compression de l’intégralité des données en cas de saturation de l’espace disque. En appliquant cette technique à un dataset de données de géolocalisation, nous montrons qu’elle permet d’exploiter ces données de façon quasi-identique à une version non-compressée, mais que la précision des résultats décroît avec l’âge des données, instaurant ainsi une dégradation progressive des données renforçant la protection de la vie privée.

### Auteurs

- Rémy Raes (Centre Inria de l’Université de Lille)
- Adrien Luxey-Bitri (Centre Inria de l’Université de Lille)
- Romain Rouvoy (Centre Inria de l’Université de Lille)
- François Taïani (Centre Inria de l’Université de Rennes)
- Davide Frey (Centre Inria de l’Université de Rennes)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #52

### Titre

Conception et validation de multicoeur hétérogènes avec NOC et accélérateurs matériels sur Système sur Puce FPGA

### Résumé

Sous l'impulsion de la loi de Moore, l'évolution rapide des systèmes embarqués et du HPC pose de manière régulière la nécessité de besoins en formation en cursus ingénieur prenant en compte architecture, accélérateurs matériels, implémentation physique, et programmation parallèle. L'ENSTA Paris a mis en place depuis 5 ans un cours MPSOC (Multiprocessors System on Chip) pour les élèves ingénieurs de 3A dans lequel les élèves concoivent un multicore hétérogène de 5 coeurs , 1 ARM9 dual-core superscalaire, 4 processeurs Microblaze configurables connectés par un réseau sur puce (NOC - Network on Chip) AXI aux mémoires locales et DDR. Cette architecture est enrichie par des accélérateurs matériels dédiés générés par HLS (High Level Synthesis) et intégrés dans le multicoeur. Cette architecture est implémentée sur un Soc (System on Chip) circuit Zynq FPGA Xilinx et validée par exécution sur carte zedboard.  Le projet impose une exploration automatisée (Design Space Exploration) multiobjective du MPSOC <Max P, Min R, Min E> d'optimisation de la performance, de la minimisation des ressources et de minimisation de l'énergie. Les élèves ont le choix des applications parallèles implémentées qui souvent sont issues du traitement d'images, de la robotique et de l'IA. Ce cours exigeant permet aux élèves d'etre exposés aux problématiques d'architecture, de parallélisme, de système et d'implémentation physiques sous des contraintes de temps. La présentation exposera les travaux résultant des projets des élèves, les difficultés rencontrées les solutions apportées et les évolutions futures.

### Auteurs

- Omar HAMMAMI (IP PARIS)

### Sujet

- Architecture
- Parallélisme
- Système

### Type de présentation

Présentation sans poster

---

## Soumission #53

### Titre

Batching the tasks of the LU factorization with partial pivoting on top of runtime systems

### Résumé

Task-based runtime systems have demonstrated efficiency in leveraging the capabilities of large heterogeneous architectures. Many linear algebra algorithms and applications have been implemented on top of runtime systems to increase their performance. However, the LU factorization with partial pivoting has not yet been successfully implemented using task-based runtime systems. This operation is used to solve large dense linear systems in numerical simulations, such as the Maxwell equations in electromagnetism. This factorization is a major part of the High Performance Linpack (HPL) benchmark used in the TOP500 to evaluate and rank supercomputers.  

We explore solutions to implement efficient LU factorization with partial pivoting using the sequential task-flow programming model. These solutions have been implemented in the dense linear algebra library Chameleon on top of the StarPU runtime system.  

We showed that, due to the pivoting strategy, this algorithm generates a large number of very small tasks, which usually overloads the runtime system and makes it inefficient. With a naive task batching strategy, we improved the efficiency and reduced the number of tasks. We propose solutions to adapt the batch size to the granularity of the tasks.  
In order to do that, we first distinguish two types of tasks and set an adapted batch size for each. Then, we introduce a heuristic based on the number of operations per tasks to adapt the batch size to the computational complexity of the tasks during the factorization.

Experiments conducted on our cluster with these optimizations show that our LU factorization with partial pivoting asymptotically reaches about 96% of the performance of the non-pivoting algorithm. Thanks to the adaptive batch size mechanism, the performance peak is reached even faster.

### Auteurs

- Alycia Lisito (Eviden, Inria, LaBRI, Université de Bordeaux)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #54

### Titre

Placement de tâches MPI pour minimiser la charge par carte réseau et améliorer la localité

### Résumé

Avec l’augmentation en taille et en complexité des supercalculateurs, il est devenu crucial de faire correspondre le schéma de communication des applications à la topologie matérielle sous-jacente. Cette optimisation permet de minimiser le temps passé dans les communications et de limiter la contention générée sur le réseau. Certaines implémentations MPI tiennent compte de la topologie, principalement intra-nœud, pour adapter les communications effectuées au sein des opérations collectives de communication. Cependant, ces implémentations ne tiennent pas compte de la topologie réseau de manière générique, ni de la charge de communication générée sur les cartes réseau. Cette métrique pourrait aider à améliorer les performances car, bien que les caractéristiques du réseau indiquent une certaine bande passante, la bande passante en sortie d’un nœud reste inférieur. Lors d’une succession de communications collectives, le même algorithme sera appliqué, ce qui aura comme conséquence de générer un déséquilibre sur la charge de communication à effectuer par carte réseau. Ainsi, lors d’un broadcast binomial enchaîné en conservant la même racine, le volume de communications effectuées à partir du nœud sur lequel la racine est située sera bien supérieur à celui des autres nœuds, ce qui induit une surcharge sur la carte réseau du nœud et ralentit les communications dépendantes des données envoyées par la racine.
Afin d’adapter la charge de communication par nœud lors de communications enchainées, nous mettons au point un outil de renumérotation des processus MPI pour les opérations de communication collectives. La métrique principale que nous cherchons à minimiser est la charge de communication par nœud. Cependant, la localité des communication est une autre métrique que nous essayons de prendre en compte. Les résultats préliminaires montrent que notre outil de renumérotation des rangs des processus MPI permet de réduire la charge par carte réseau ainsi que le nombre de messages remontant dans la topologies réseau dans le cas d’un enchaînement de broadcasts ou de scatters binomial.

### Auteurs

- Brice GOGLIN (inria)
- Julien JAEGER (CEA)
- Guillaume MERCIER (inria)
- Thibaut PEPIN (CEA)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #55

### Titre

Software transactional memory for parallel meshing applications

### Résumé

Parallelizing remeshing algorithms presents significant challenges due to their dynamic nature, where operations alter data that dictates subsequent actions. We aim to address the problems
created by these dynamic workloads without relying on conflict avoidance, and propose an
alternative approach to ensure data integrity in this context. To that end, we leverage specific
data structure, synchronization mechanism and programming language features. We bench-
mark our implementation with two algorithms: a topology-heavy kernel with non-trivial parallelization, and a simpler vertex relaxation routine. Preliminary results suggest STM effectively manages conflicts, maintaining structure validity under concurrency. Our work offers a
robust framework for parallel remeshing, balancing correctness and scalability.

### Auteurs

- Isaïe Muron (CEA)
- Franck Ledoux (CEA)
- Cédric Chevalier (CEA)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #56

### Titre

Automatic Multi-Versioning of Computation Kernels

### Résumé

Program optimization is crucial for scientific programs that can run for several days or even weeks. Generating code tailored for a specific target architecture is key to exploiting the hardware with maximum efficiency, both in terms of performance and energy savings, allowing more precise and complete experiments to be run in a shorter time while consuming less energy.
Generalist optimization tools have become better over the years, enabling automatic generation of efficient machine code. These tools aim to achieve good performance on average across a range of different programs, and are thus missing optimization decisions that may be beneficial for specific programs, or runs of a program with a given input data.
Approaches such as multi-versioning or iterative compilation aim to specialize optimizations to specific programs and input data, but are hard to put into practice, and often only rely on static information for generating code. Our approach aims to leverage knowledge from the execution contexts of a program to derive optimization strategies tailored to these specific execution contexts, and to automatically generate code using known techniques such as polyhedral loop transformations.

### Auteurs

- Raphaël Colin (Inria)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #57

### Titre

Méduse : reproduire des circuits obsolètes

### Résumé

Afin de restaurer et recréer des systèmes informatiques des années 1970 et 1980, nous proposons un outillage matériel et logiciel pour assister à la rétro-ingénierie et la réplication de circuits imprimés en électronique numérique, la Méduse. À partir de séries de mesures de continuité électrique entre points du circuit, la Méduse produit un graphe des connexions ou netlist, qui peut être exporté sous forme de code Verilog pour analyse, simulation, ou synthèse sur FPGA. Son utilisation est illustrée par la rétro-conception de cartes d'un mini-ordinateur Mitra 125 de 1978.

### Auteurs

- Caroline Collange (IRISA, Inria, CNRS, Univ Rennes)

### Sujet

- Architecture

### Type de présentation

Présentation sans poster

---

## Soumission #58

### Titre

Connecting Kokkos with the Polyhedral Model

### Résumé

The modernization of programming paradigms force the scientists to change their default programming language for writing simulations (for examples, using C++ instead of Fortran). Writing simulation codes is a complex task and in order to improve performance, developers need to program in a way that utilizes all of the resources of a supercomputer. Modern C++ libraries such as Kokkos are becoming increasingly popular as they help ease development of parallel applications.
Although Kokkos provides simplified access to parallel programming for heterogeneous hardware targets, it does not include advanced optimizing code transformations. In this paper, we propose to make advanced loop optimizing and parallelizing transformations based on the polyhedral model available for Kokkos.

### Auteurs

- Ugo BATTISTON (INRIA)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #60

### Titre

A Probabilistic Approach to Explore Spatial and Temporal Locality for Lossless Compression in CFD Simulations

### Résumé

Modern applications are able to tackle larger workloads than ever before, mainly due to the democratization of GPU-based architectures. Despite this, the overall ratio of storage space per computing unit is diminishing, turning memory management into a limiting factor.
Compression has been explored as a solution for handling large datasets in visualization, data storage, etc. However, few works address this topic for numerical simulation purposes. 
In this paper, we explore the challenges of leveraging lossless compression to reduce memory usage in GPU CFD simulations. We propose a compact data representation based on a common predictor + delta algorithm to split the data into a base with coarser resolution than the initial mesh and a compressible residual.

We assume that spatial coherence far from discontinuities is strong enough for a value at a given position to be a good candidate to predict neighboring values. Temporal coherence can then be leveraged by transferring the residual between the host and the GPU separately from the base, which may be reused during several iterations.

To evaluate the relevance of our method, we present the basis of a probabilistic description of simulation data to assess the prospective compression gains achievable by a given approximation.

### Auteurs

- Téodora Hovi (Université de Reims Champagne-Ardennes | CEA)
- François Letierce (CEA)
- Laurent Lucas (Université de Reims Champagne-Ardennes)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #61

### Titre

FedE-ator : A framework for energy consumption analysis of federated learning in distributed systems

### Résumé

Federated learning (FL) is a machine learning (ML) technique with multiple entities collaboratively training a model while keeping their data decentralized. The growth of ML is driven by increasingly large and computationally demanding ML models and datasets, leads to substantial energy consumption. FL also faces this challenge, with the distributed and complex design of FL, simply estimating energy by simulation may not be enough, accurately monitoring its energy usage becomes necessary. This work focuses on developing FedE-ator, a framework designed to measure the actual energy consumption of FL processes in real-world distributed systems. As a first step in validating the framework's usability, we conducted an experiment on the CIFAR10 dataset, systematically varying FL settings (server strategies, client models) and hardware configurations (CPU frequencies), with multiple repetitions. The experiment was carried out on the Grid'5000 (g5k) platform.

### Auteurs

- Mai Huong Do (IRIT, UNIVERSITY PAUL SABATIER)
- Millian Poquet (IRIT, UNIVERSITY PAUL SABATIER)
- Georges Da Costa (IRIT, UNIVERSITY PAUL SABATIER)

### Sujet

- Parallélisme
- Système

### Type de présentation

Présentation sans poster

---

## Soumission #62

### Titre

Optimisation de la contraction de tenseurs grâce à l'utilisation de supports d'exécution appliquée à la méthode Coupled-Cluster

### Résumé

Les systèmes de tâches et de tâches distribuées ont prouvé leur capacité à utiliser les ressources de systèmes matériels distribués et hétérogènes. Ils permettent d'exposer le maximum de parallélisme, d'utiliser pleinement et efficacement les ressources et de passer à l'échelle, au moins dans le cas du calcul matriciel.
Une nouvelle question se pose alors quant à la généralisation de ce résultat au calcul tensoriel. En effet l'algèbre multidimensionnelle prend une place très importante dans le calcul haute performance, en particulier récemment avec le développement très rapide de l'intelligence artificielle. D'autre part d'autres domaines comme la chimie quantique calculatoire, qui nous intéresse ici, utilisent des tenseurs depuis plus longtemps.
Dans notre étude, nous étendons les capacités du logiciel d'algèbre linéaire dense Chameleon à la contraction de tenseurs. Pour notre application, on se concentre sur des tenseurs à faible nombre de dimensions (inférieur ou égal à 6) mais dont les dimensions sont grandes, que l'on trouve dans la méthode coupled-cluster[1].
La contraction de tenseurs apporte plusieurs nouvelles difficultés par rapport au produit de matrices. En effet, les dimensions qui sont contractées sont ordonnées arbitrairement. Il est quand même possible de se ramener à des opérations matricielles classiques, mais il est potentiellement nécessaire d'effectuer des permutations/transpositions de nos tenseurs. Cela permet de profiter des opérations matricielles optimisées de Chameleon. Par ailleurs, à mesure que le nombre de dimensions augmente, les tenseurs deviennent très rapidement trop grands. Il faut donc également répondre au problème de stockages des tenseurs.
Pour appliquer notre système de tâches à ce problème, nous mettons en évidence les transformations élémentaires et composables qui permettent de réaliser toutes les permutations possibles des dimensions des tenseurs, ainsi que leur implémentation au dessus du support d'exécution StarPU.
Nous appliquons notre implémentation au calcul des résidus de la méthode coupled-cluster avec density fitting afin d'en illustrer l'efficacité.

[1] Deprince, Eugene & Sherrill, C. (2013). Accuracy and Efficiency of Coupled-Cluster Theory Using Density Fitting/Cholesky Decomposition, Frozen Natural Orbitals, and a t1-Transformed Hamiltonian. Journal of Chemical Theory and Computation. 9. 2687–2696. 10.1021/ct400250u.

### Auteurs

- Brieuc (Centre Inria de l'Université de Bordeaux)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #63

### Titre

Efficient Pyramidal Analysis of Gigapixel Images on a Decentralized Modest Computer Cluster

### Résumé

Analyzing gigapixel images is widely recognized as computationally demanding. That is why we introduce PyramidAI, a technique for analyzing gigapixel images with reduced computational cost. It efficiently reduces computational requirements by adopting a gradual approach to image analysis, beginning with lower resolutions and progressively concentrating on regions of interest for detailed examination at higher resolutions. In addition to our adaptive resolution scheme, we implemented two strategies for tuning the accuracy-performance trade-off, validated against the Camelyon 16 dataset composed of biomedical images. Our results demonstrate that PyramidAI substantially decreases the amount of processed data required for analysis by up to 2.65x, while preserving the accuracy in identifying relevant sections on a single computer. To ensure democratization of gigapixel image analysis, we evaluated the potential to use mainstream computers to perform the computation by exploiting the high parallelism potential of the approach. Our simulator emphasized that synchronization to balance the load before initiating the next resolution level tiles analysis is not required. The most efficient and stable data distribution strategy for this use-case is the Round-Robin, while the load balancing technique is the graph leaves work-stealing one when the number of available workers increases. Our implementation using the DecentralizePy python framework, highlighted the same conclusions in a real-world setting. It offers the possibility to reduce from a few minutes when using 12 workers. This method offers a practical solution for efficient large-scale image analysis.

### Auteurs

- Marie Reinbigler (Télécom Sudparis, Institut Polytechnique de Paris, Inria)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #64

### Titre

Uplifting ocean models PDE solvers with Poseidon a Domain Specific source-to-source compiler.

### Résumé

A wide range of heterogeneous user communities develop and use ocean model simulations, such as those developing biological ice models and components accounting for other natural phenomena and those using models to predict climate in a hundred years. Consequently, it is not easy to develop code that is efficient for all these use cases in terms of extensibility, performance portability, and ease of use.

Research has been conducted mainly on disruptive approaches, particularly using domain-specific languages (DSLs) and their attached domain-specific (DS) compiler optimization passes. Knowing more about the code behavior allows DSL compilers to be much more greedy in their optimization, which will be more efficient on a given architecture and potentially improve performance portability.

However, existing code is extremely valuable, complex, and large, particularly in the ocean modeling community.
Thus, using a domain-specific language to rewrite an entire, or just some parts, of an existing code is often evaluated as too costly because it requires significant human resources and time investments.

In this work, we investigate our source-to-source Poseidon compiler. It uses a new methodology by considering the existing code of the dynamical cores of ocean models as an embedded DSL. In this way, we can enrich the information extracted from the code with domain-specific information. Helping HPC and numerics experts discuss codesign, Poseidon effectively lifts various restrictions compilers suffer from performing in-depth optimizations and code analysis.

We have applied Poseidon on three cases, each time only focusing on the Dynamical Core part of the code:
* A tutorial Fortran code (500LOC) solving a 2D shallow water model with Runge-Kutta (RK2) method.
* Schweinshaxe, a (13kLOC) Fortran Object Oriented code, also solving 2D shallow water model: Arakawa C grid and the Multi-step time integrator (AB3-AM4) from CROCO.
* CROCO, a >100kLOC legacy-Fortran code. We focus on the same kind of solver as with Schweinshaxe.

Applying some state-of-the-art compiler optimization passes, with the domain-specific knowledge we added, we can transform existing Fortran code without any parallelization information to GPU with parallelization and performance optimizations beyond regular compilers.

### Auteurs

- Hugo Brunie (University Of Grenoble Alpes)
- Martin Schreiber (University Of Grenoble Alpes)
- Julien Remy (University Of Grenoble Alpes)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #65

### Titre

A fast implementation of 3D wavelet compression on GPU

### Résumé

GPUs are widely used in high-performance computing for performing computationally inten-sive tasks. However, GPUs have fixed memory capacities that are much smaller than those ofCPUs, often limiting the full exploitation of their computational power. Moreover, the memorybus between CPUs and GPUs is an order of magnitude slower, hindering the efficient feedingof data to GPUs during computation. To overcome these limitations, we developed an efficientcompression kernel for GPUs. Our implementation relies on the wavelet method used in theJPEG2000 format and is highly optimized in CUDA using the GPU’s shared memory. We de-monstrate that our kernel can compress and decompress data faster than transferring data overthe PCIe bus, allowing to store more data and transferring them faster.

### Auteurs

- Atoli Huppé (INRIA)
- Bérenger Bramas (INRIA)
- Clément Flint (INRIA)
- Stéphane Genaud (ICube - Strasbourg)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #66

### Titre

Modélisation et projection de performances d'applications parallèles sur environnement GPU

### Résumé

With the advent of heterogeneous systems that combine CPUs and GPUs, designing a supercomputer becomes more and more complex. The hardware characteristics of GPUs significantly impact the performance. Choosing the GPU that will maximize performance for a limited budget is tedious because it requires predicting the performance on a non-existing hardware platform.

In this paper, we propose a new methodology for predicting the performance of kernels running on GPUs. This method analyzes the behavior of an application running on an existing platform, and
projects its performance on another GPU based on the target hardware characteristics. The performance projection relies on a hierarchical roofline model as well as on a comparison of the kernel's assembly instructions of both GPUs to estimate the operational intensity of the target GPU.

We demonstrate the validity of our methodology on modern NVIDIA GPUs on several mini-applications. The experiments show that the performance is predicted with a mean absolute percentage error of 20.3~\% for LULESH, 10.2~\% for MiniMDock, and 5.9~\% for Quicksilver.

### Auteurs

- Lucas Van Lanker (CEA, DAM, DIF, F-91297 Arpajon, France)
- Hugo Taboada (CEA, DAM, DIF, F-91297 Arpajon, France)
- Elisabeth Brunet (Télécom Sud Paris, Inria - Evry)
- François Trahay (Télécom Sud Paris, Inria - Evry)

### Sujet

- Architecture

### Type de présentation

Présentation avec poster

---

## Soumission #67

### Titre

Rejeu de leviers environnementaux dans des infrastructures de Clouds et continuums

### Résumé

Les datacentres ont une empreinte mondiale environnementale significative. Celle-ci se décline en plusieurs aspects, comme l'émission carbone, l'utilisation de terres et métaux rares, ou encore la consommation d'eau et d'électricité. Pour gérer ces impacts, les fournisseurs de datacentres ont à leur portée un éventail de techniques, appelées "leviers" qui permettent de changer le comportement des composants des datacentres. L'étude de leviers clé, tels que l'extinction ou le ralentissement de ressources inutilisées, ou la consolidation de VMs, jouent un rôle important dans l'atténuation de ces empreintes. Cependant, la combinaison de ces leviers est difficile à cause de l'hétérogénéité de composants et services présents dans les datacentres, et l'incompatibilité d'application entre certains leviers. Aucune méthode efficace n'existe jusqu'ici pour résoudre ce problème d'orchestration de leviers à grande échelle.

Ma thèse, qui a débuté en octobre 2024, s'inscrit alors dans ce contexte, en s'appuyant notamment sur les travaux d'anciens doctorant de mon équipe sur la modélisation, l'orchestration et la combinaison de leviers hétérogènes. Elle consiste en :
- l'extension du modèle existant pour prendre en compte une grande diversité de leviers, leurs impacts et leurs contraintes de placement,
- la conception et le développement d'algorithmes d'orchestration automatique de leviers à grande échelle,
- l'évaluation des atténuations d'impacts environnementaux
- l'extension de la méthode au continuum Cloud-Fog-Edge
Une importance sera aussi accordée à la modélisation d'une diversité de scénarios pouvant se présenter aux fournisseurs de datacentres. Les prises de décisions lors de ces scénarios pourront alors être simulées et rejouées de manière à minimiser les empreintes associées.

J'ai donc pu formaliser dans ces premiers mois de thèse une formalisation du "problème de placement de leviers", en présentant aussi une analyse théorique de sa complexité, une stratégie de gestion des leviers, ainsi qu'une première validation de cette méthode de résolution à grande échelle. Dans ce workshop, ma présentation consisterait alors en une présentation de mon sujet et de mon plan de thèse, ainsi que des premiers résultats obtenus.

### Auteurs

- Thomas Stavis (Univ Lyon1, Inria, ENS de Lyon, CNRS Lyon, France)
- Laurent Lefèvre (Univ Lyon1, Inria, ENS de Lyon, CNRS Lyon, France)
- Anne-Cécile Orgerie (Univ. Rennes, Inria, CNRS, IRISA, Rennes, France)

### Sujet

- Architecture

### Type de présentation

Présentation sans poster

---

## Soumission #68

### Titre

Efficient and portable neutron transport sweep kernels on multicore CPUs and GPUs using Kokkos

### Résumé

La résolution de l’équation de transport neutronique avec la méthode des ordonnées discrètes
(SN) en angle et une discrétisation de type Galerkine Discontinue (DG) en espace repose sur
une imbrications d’algorithmes itératifs. À chaque itération interne, un balayage ordonné du
maillage spatial pour un ensemble de directions permet de calculer l’itéré suivant, par l’as-
semblage et la résolution d’un petit système linéaire local dans chaque cellule. Le noyau de
balayage étant la partie la plus chronophage de la résolution, il est essentiel de le paralléliser
efficacement. Avec la part croissante des GPUs dans les architectures de calculs modernes, il
devient crucial d’exploiter aux mieux ces accélérateurs sous peine de se priver de la majorité
de la puissance de calcul offerte par le hardware. Dans ce travail, nous présentons différentes
implémentations parallèles du balayage pour les CPUs multicœurs et les GPUs dans le cadre
de schémas spatiaux d’ordres élevés. Ces implémentations sont basées sur le framework C++
Kokkos pour la portabilité sur différentes architectures. Sur CPU, une stratégie de vectorisation
portable basée sur les types SIMD de Kokkos, un réarrangement de la mémoire et des boucles
dans le balayages, ainsi qu’une implémentation légère de tâches au sein de Kokkos permettent
d’obtenir de très bonnes performances sur CPU. Sur GPU, une adaptation de l’algorithme est
nécessaire, et passe par une maximisation du degré de parallélisme disponible à chaque étape,
et un assemblage/résolution batchés des systèmes linéaires locaux. Après optimisation du sol-
veur linéaire, les performances sur GPU sont très largement limitées par la bande passante de
la mémoire globale, notamment pendant la phase d’assemblage.

### Auteurs

- Gabriel Suau (CEA)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #69

### Titre

Fork-nox: a new virtualization technique to enforce system security

### Résumé

Operating system security is a major concern, because vulnerabilities discovered at this layer would endanger the whole software stack.
Despite many efforts, kernel security mechanisms are not isolated enough from the kernel to offer strong integrity guarantees.
Indeed, the trusted computing base of these mechanisms incorporates by design the whole kernel and its drivers.
In the case of Linux, this represents nearly 25 millions lines of code, difficult to trust and hard to debug.
With this project, we argue that integrity guarantees on kernel security can be achieved using a more privileged layer without sacrificing the semantics.
Building on this idea, we employ hardware virtualization to run Fork-nox, a small security hypervisor.

We implement Fork-nox as a Linux module, which separates itself from the kernel to gain more privileges, deploying necessary hypervisor features.
Moreover, we have designed it to be a minimal, independent and auditable codebase.

With this project, we demonstrate the efficiency of our tool by enforcing memory protection, and evaluating the hardening of kernel security interposition.
Hence, our goal is to ensure kernel security system's integrity.
Fork-nox creates a trusted computing base in the kernel to safely handle security threats.
Thus, we envision a hardened hook mechanism to perform advanced security checks and optionally livepatching through a safe interface allowing to define on-demand policies.

### Auteurs

- Jean-François Dumollard (Benagil Team, Inria Saclay, Télécom SudParis, Institut-Polytechnique de Paris, Institut Mines-Télécom)
- Nicolas Derumigny (Benagil Team, Inria Saclay)
- Mathieu Bacou (Télécom SudParis, IP Paris, Inria Saclay)
- Gaël Thomas (Benagil Team, Inria Saclay)

### Sujet

- Système

### Type de présentation

Présentation avec poster

---

## Soumission #70

### Titre

Exploring C++ Standard Parallelism Features for GPU Programming in a Particle-In-Cell Application

### Résumé

The C++17 standard introduced stdpar as a high-level parallelism model, which NVIDIA la-
ter implemented to support GPUs in heterogeneous architectures. This study evaluates NVI-
DIA’s stdpar implementation on GPUs within a GPU-based Particle-In-Cell code, comparing it
to Thrust and Kokkos in terms of performance and ease of use. Our results indicate that while
stdpar significantly enhances developer productivity, it remains less efficient in terms of raw
performance. It shows an advantage at low particle counts but loses efficiency as the count
increases, becoming up to 1.88× slower than Kokkos and 1.34× slower than Thrust on GH200.

### Auteurs

- Ester El Khoury (Commissariat à l'énergie atomique et aux énergies alternatives, Saclay, France)
- Mathieu Lobet (Commissariat à l'énergie atomique et aux énergies alternatives, Saclay, France)
- Laurent Colombet (Commissariat à l'énergie atomique et aux énergies alternatives, DAM Ile de France, France)
- Julien Bigot (Commissariat à l'énergie atomique et aux énergies alternatives, Saclay, France)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #71

### Titre

Schemes for conflict-free data-parallel physics-informed neural networks

### Résumé

Physics-informed neural networks (PINNs) [5] have emerged as a powerful tool for solving complex physical problems by integrating domain knowledge into deep learning models. 

However, their training is often inefficient due to the interplay of multiple loss terms, which act as implicit regularizers.This challenge becomes even more pronounced when dealing with high-dimensional, multi-physics, or nonlinear problems that demand extensive computational resources. Efficient training schemes are therefore crucial for scaling PINNs to real-world applications. Various strategies have been proposed to mitigate this issue, including hyper-parameter optimization [3],multi-objective frameworks [1], and conflict-free schemes [4].

In this work, we explore data-parallel and conflict-free approaches to achieve scalable, high throughpout training [2]. We extend [2] and compare different methods for assembling the various loss components in a decentralized manner, drawing inspiration from traditional conflict-free gradient averaging methods, all-reduce operations, and aggregation mechanisms such as Adasum and PCGrad. Using the Horovod distributed training framework, we achieve scalable parallelization without compromising model accuracy. Our results demonstrate that increasing the number of GPUs maintains efficiency and ensures robust convergence. We also compare the classical allreduce application to other routines, and compare them. Our findings show that PINN training can be both highly scalable and computationally efficient with the right acceleration strategies. By integrating SciML-specific insights with modern DL frameworks, we increase performance of PINNs. This work paves the way for large-scale, high-throughput physics-informed machine learning (PIML), enabling its application to complex scientific and engineering problems

### Auteurs

- Paul Escapil-Inchauspé (Inria Chile)
- Luis Marti (Inria Chile)
- Nayat Sanchez-Pi (Inria Chile)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #72

### Titre

Bridding OT and PaaS in Edge-to-Cloud Continuum

### Résumé

The Operational Technology Platform as a Service (OTPaaS) initiative provides a structured framework for the efficient management and storage of data. It ensures excellent response times while improving security, reliability, data and technology sovereignty, robustness, and energy efficiency, which are crucial for industrial transformation and data sovereignty. This paper illustrates successful deployment, adaptable application management, and various integration components catering to Edge and Cloud environments. It leverages the advantages of the Platform as a Service model and highlights key challenges that have been addressed for specific use cases.

### Auteurs

- Carlos Jaime BARRIOS HERNANDEZ (LIG/INRIA)
- Yves DENNEULIN (GRENOBLE-INP/LIG/INRIA)

### Sujet

- Architecture
- Système

### Type de présentation

Présentation avec poster

---

## Soumission #73

### Titre

Utilisation d'une mini-application de simulation en volumes finis pour expérimenter diverses stratégies de parallélisation multi-GPU

### Résumé

Les simulations numériques s'appuyant sur des schémas en volumes finis sur des maillages non-structurés sont très utilisées en mécanique des fluides, mais demandent un effort considérable pour exploiter des architectures multi-GPU de manière efficace.

Ces travaux explorent, au travers d'une mini-app C++ proposée par Airbus, d'explorer plusieurs stratégies de parallélisation du code de manière la plus indépendante possible des aspects physiques de la simulation. En particulier, nous avons examiné l'intérêt d'utiliser un partitionneur, tel que Scotch, pour réorganiser les mailles afin d'augmenter la localité mémoire et de réduire les échanges de données ainsi que les synchronisations nécessaires entre les GPUs. Ensuite, nous avons évalué l'efficacité de l'utilisation de bordures d'épaisseur arbitraire (halos de ghost cells), pour minimiser les communications. Nous avons également analysé l'efficacité de l'utilisation de la mémoire unifiée entre les GPU au sein d'un même nœud. De plus, nous avons exploré la possibilité de recouvrement des communications par des calculs de sous-domaines. Par ailleurs, nous avons étudié l'utilisation de CUDA graphs pour améliorer l'enchaînement des noyaux. Enfin, nous avons évalué l'utilisation de CUDASTF pour automatiser la gestion de l'asynchronie et recouvrir les calculs.

Pour conduire ces expériences d'une manière non invasive dans le code ainsi que dynamique, nous avons implémenté des classes C++ génériques qui autorisant une parallèlisation hiérarchique arbitraire, c'est-à-dire qui permettent de tester facilement diverses combinaisons et configurations de méthodes de décomposition telles que le partitionnement de cellules ou la coloration de faces. Cette idée généralise les résultats à l'état de l'art qui, jusqu'ici, étaient limités à deux niveaux de coloration successifs.

Nous pensons que le travail effectué sur cette proxy-app peut d'une part être facilement poursuivi par l'ajout d'autres stratégies de passage à l'échelle, fondées sur des modèles de programmation émergents tels que Kokkos ou Raja, et d'autre part qu'il constituera une sorte de guide de bonnes pratiques pour la communauté s'intéressant au portage multi-GPU de codes opérants sur des maillages non-structurés.

### Auteurs

- Line Fremery (Inria)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #74

### Titre

Towards optimal reconfigurable constant multipliers

### Résumé

This paper introduces a novel algorithm for generating run-time reconﬁgurable single constant multipliers which are optimal in the number of adders and multiplexers they use. Optimality is ensured by an exhaustive exploration of the design space mixing constraint programming, depth-ﬁrst search, and branch-and-bound techniques. Experimental evaluations demonstrate signiﬁcant reductions in resource usage compared to prior methods. The proposed approach also works for larger sets of target constants. Some applications to neural network inference are discussed.

### Auteurs

- Bastien BARBE (INSA Lyon)
- Xiao PENG (INSA Lyon)
- Anastasia VOLKOVA (INRIA)
- Florent De DINECHIN (INSA Lyon)

### Sujet

- Architecture

### Type de présentation

Présentation avec poster

---

## Soumission #75

### Titre

Vers un banc d'essai flexible pour les systèmes d'exploitation réseau dans le Computing Continuum

### Résumé

La réalisation complète du Computing Continuum reste un défi en raison du manque d'infrastructures de recherche adaptées pour l'expérimentation à grande échelle. Pour y remédier, nous proposons un banc d'essai conceptuel visant à améliorer la reproductibilité, l'évolutivité et la robustesse des expériences de réseau Computing Continuum. Ce banc d'essai offre une grande flexibilité, permettant aux expérimentateurs de modifier les systèmes d'exploitation des équipements réseau et de reconfigurer dynamiquement les topologies réseau. Nous définissons trois scénarios d'utilisation distincts, allant des environnements multi-opérateurs aux architectures de réseau internes des fournisseurs de télécommunications, tous déployables sur la topologie de réseau proposée. L'article explore également des solutions pour la gestion de la topologie virtuelle, le déploiement du système d'exploitation et l'orchestration des services.

### Auteurs

- Julien CAPOSIENA (Laboratoire CITI - Bâtiment Hedy Lamar - 6 Av. des arts 69100 Villeurbanne - France)
- Frédéric LE MOUËL (Laboratoire CITI - Bâtiment Hedy Lamar - 6 Av. des arts 69100 Villeurbanne - France)
- Oscar CARRILLO (Laboratoire CITI - Bâtiment Hedy Lamar - 6 Av. des arts 69100 Villeurbanne - France)
- Baptiste JONGLEZ (Nantes Université, École Centrale Nantes, CNRS, Inria, LS2N, UMR 6004, F-44000 Nantes, France)
- Pierre NEYRON (CNRS, Univ. Grenoble Alpes, Inria, Grenoble INP, LIG, UMR 5217, 38058 Grenoble, France)
- Thierry ARRABAL (Laboratoire CITI - Bâtiment Hedy Lamar - 6 Av. des arts 69100 Villeurbanne - France)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #76

### Titre

VoliMem : Leveraging a user-land page table towards transparent usage of persistent memory

### Résumé

Over the last decades, memory technology has evolved significantly, resulting in the creation of failure-resilient persistent memory (PMEM). Due to its page-cache bypassing and byte-addressability, PMEM offers the durability of SSD with speeds approaching those of modern RAM. However, hardware support alone is insufficient as processor caches remain volatile, which results in data inconsistency in case of failure. For that reason, using PMEM also requires code instrumentation to log memory accesses. Currently, it is necessary to manually instrument the code, which is error-prone and adds additional burden on developers.

We propose VoliMem, a user-space runtime that relies on virtualization to provide \emph{transparent} persistent memory environment for application developers. Namely, VoliMem creates a virtualized process-like abstraction capable of accessing a page table directly in userland. The userland page table is therefore our tool to implement transparent logging using two possible techniques. The first one consists of intercepting writes by removing corresponding permission to the pages. The second one leverages the dirty bit set by the hardware each time when a page is modified. 

With the help of the VoliMem page table, developing failure-resilient applications with PMEM can become as easy as using only volatile memory. Modifying allocation sites and making periodic snapshots is sufficient to ensure that a legacy application, such as Memcached, is resilient to system crashes. Furthermore, techniques that we apply are language agnostic, as we rely on hardware mechanisms, that are invisible at the application level. So far, we successfully implemented persistency for standard C++ data structures, and we are in the process of providing such integration for Rust and Python applications.

### Auteurs

- Jana Toljaga (Inria Saclay, Telecom SudParis, Institut Polytechnique de Paris)
- Nicolas Derumigny (Inria Saclay, Telecom SudParis, Institut Polytechnique de Paris)
- Yohan Pipereau (Telecom SudParis, Institut Polytechnique de Paris)
- Mathieu Bacou (Télécom SudParis, IP Paris, Inria Saclay)
- Gaël Thomas (Inria Saclay)

### Sujet

- Système

### Type de présentation

Présentation avec poster

---

## Soumission #77

### Titre

Modèle de micro-data center pour l’évaluation de l’empreinte carbone et l’optimisation énergétique

### Résumé

Les entreprises se sont tournées vers l'hébergement Cloud pour faciliter l'administration et maîtriser les coûts. Cependant, les data centers partagés posent des problèmes de contrôle des données, notamment en termes de géolocalisation et de protection de la vie privée, car les données de plusieurs clients peuvent être réparties mondialement, soulevant ainsi des questions juridiques et de conformité aux lois sur la protection des données. De plus, la forte consommation d’énergie des data centers génère des émissions significatives de gaz à effet de serre, aggravées par la dépendance aux services Cloud. Les micro-data centers offrent une alternative en réduisant l’empreinte carbone grâce à une efficacité énergétique locale, en respectant les réglementations de souveraineté des données et en diminuant la latence grâce à une proximité accrue avec les utilisateurs finaux. Cependant, ils doivent être faciles à gérer et permettre un suivi précis de l’empreinte énergétique et carbone à différents niveaux (services, VM, serveurs, etc.). Nos travaux proposent de modéliser un micro-data center comme un jumeau numérique avec divers niveaux de granularité, allant du data center aux serveurs, racks, services et workloads. Cette approche permet d’évaluer l’empreinte carbone et la consommation d’énergie en tenant compte des profils d’applications. En preuve de concept, nous intégrons des données statiques pour identifier les principaux facteurs d’émission de GES à chaque niveau et utilisons des wattmètres logiciels pour obtenir des informations en temps réel sur les workloads et leurs possibles placements et migrations, offrant ainsi une analyse détaillée de l’impact environnemental.

### Auteurs

- Noue Osta (INSA Lyon, Laboratoire CITI)
- Philippe Roose (UPPA, LIUPPA)
- Jérôme Gaysse (SPIE ICS)
- Elene Anton (UPPA, LIUPPA)
- Fredéric Le Mouël (INSA Lyon, Laboratoire CITI)

### Sujet

- Système

### Type de présentation

Présentation sans poster

---

## Soumission #78

### Titre

Technologies habilitantes pour l’acquisition et le traitement en temps réel de grands volumes de données et leurs applications aux télescopes astronomiques géants et aux systèmes radar

### Résumé

L'émergence de très grandes infrastructures pour l'étude et la caractérisation du monde physique entraîne une augmentation significative du volume de données produites, qui doivent être traitées et réduites par des systèmes informatiques toujours plus puissants et complexe. L'un des principaux défis à venir est le passage à l'Exascale, qui nécessite le développement de nouveaux outils et méthodologies pour gérer et traiter efficacement ces quantités massives de données. Un exemple de ce changement de paradigme dans le domaine de l'astronomie est le Square Kilometer Array (SKA), un projet international de radiotélescope produisant plusieurs dizaines de petaoctets par jour de données brutes. Il devient impératif de développer des outils adaptés à ces nouveaux besoins, capables de passer à l’échelle, en exploitant la croissance de la taille des problèmes pour améliorer la parallélisation et l’ordonnancement des traitements.

Le travail réalisé au cours de cette thèse vise à l'amélioration et à l'optimisation de la reconstruction d’images en radioastronomie avec DDFacet\cite{tasse_faceting_2018}. Nos premiers résultats montrent une sous-utilisation des capacités de calcul durant la phase de déconvolution, qui représente 75$\%$ du temps de traitement total. Le nouvel algorithme multi-échelle d'Offringa et Smirnov\cite{offringa_optimized_2017} a été implémenté dans DDFacet, offrant de nouvelles possibilités de parallélisme. Les travaux effectués durant cette thèse se concentrent également sur l’étude de différentes stratégies d’ordonnancement et leur impact sur diverses métriques (temps de calcul, occupation des ressources, consommation d'énergie) selon différents cas d'utilisation.

Les techniques développées pour la radioastronomie peuvent être appliquées à des problèmes connus de l'industrie, notamment dans les applications de traitement du signal en temps réel, comme le radar secondaire. L’objectif principal est d’améliorer la fiabilité du système en contrôlant la latence, en mettant un accent particulier sur la réduction des variations de latence (jitter). La première étape consiste en l'extraction d'un graphe de tâches pour étudier la parallélisation et les stratégies d'ordonnancement possibles, suivie de l'implémentation de prototypes en utilisant des outils tels que StreamPU\cite{cassagne_streampu_2023}, optimisé pour la basse latence, en prenant en compte la charge CPU et la gestion des priorités des tâches.

### Auteurs

- Hugo Gaquere (LIRA, Observatoire de Paris)
- Lionel Matias (Thales LAS)
- Frederic Vivien (Inria, ROMA)
- Olivier Aumage (Inria, Storm)
- Adrien Cassagne (Sorbonne Université, LIP6, Paris)
- Damien Gratadour (LIRA, Observatoire de Paris)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #79

### Titre

Efficient parallel deep learning

### Résumé

As deep learning models grow larger, they demand more computation power and memory to train in reasonable timeframes. Researchers and companies typically solve this by using multiple accelerators working together, which makes efficient parallelization essential. Among various parallelization strategies proposed in literature, we focus on Pipeline Parallelism, which faces two main challenges: wasted idle time from sequential computation, and excessive memory usage from storing intermediate activations. While the Zero Bubble \cite{zb} approach effectively addresses idle time issues, memory consumption remains problematic. Our research aims to enable distributed training for models that are too large to fit in accelerators' GPUs using standard methods.\\
    One promising solution we explore is rematerialization (activation checkpointing), which can significantly reduce memory usage while performing additional recomputation during the accelerators' idle time, mitigating the overhead. We formulate this as an optimization problem to find the best rematerialization strategy for specific pipelined training scenarios. We also plan to investigate other strategies such as offloading and combination with data/tensor parallelism.\\
    To support this research, we also present ELF, a new PyTorch-based library for distributed deep learning. ELF's flexible design makes it easy to implement and experiment on new ideas.

### Auteurs

- Adrien Aguila--Multner (Inria)
- Julia Gusak (Inria)
- Olivier Beaumont (Inria)

### Sujet

- Parallélisme

### Type de présentation

Présentation sans poster

---

## Soumission #80

### Titre

Vers une abstraction composable des méthodes hiérarchiques pour l’accélération de produits matrice-vecteur

### Résumé

Le produit matrice-vecteur est une opération élémentaire apparaissant dans de nombreuses
applications en calcul scientifique. Il s’agit notamment de la pierre angulaire de nombreux sol-
veurs itératifs. Accélérer cette opération permet ainsi d’améliorer la résolution de nombreux
problèmes. Nous nous intéressons à l’accélération de y = A x où A est une matrice dense liée à
des interactions entre des positions géométriques et qui par conséquent présente une structure
(hiérarchique) en tuiles de rang faible (ou une structure similaire). Dans cette configuration, les
méthodes hiérarchiques permettent d’accélérer cette opération en la faisant passer d’un coût
quadratique à une coût quasi-linéaire voir linéaire. Nous pouvons citer par exemple les ma-
trices H, les matrices H2, les matrices HODLR, les matrices HSS et la méthode des multipoles rapide (FMM). Bien que ces méthodes aient des bases communes, il y a eu
jusqu’à présent très peu de rapprochements et de tentatives d’unification entre ces dernières.
Nous proposons ainsi une abstraction de ces méthodes basée sur 4 composants : (1) un schéma
de partitionnement pour organiser la matrice en tuiles, (2) un critère d’admissibilité pour dé-
terminer les tuiles qui seront compressés (admissibles), (3) une stratégie de compression pour
approcher les tuiles admissibles (analytique, algébrique, ou encore arithmétique...), et (4) une
stratégie pour gérer les bases afin factoriser certaines étapes de compression. Ces différents
composants peuvent ensuite se spécialiser pour retrouver les différentes méthodes de la lit-
térature mentionnées précédemment. De cette abstraction, nous en avons déduis un unique
algorithme générique pouvant s’accommoder à toutes les méthodes hiérarchiques. Cette algo-
rithme composable offre une opportunité d’unifier la parallèlisation de toutes ces méthodes.
Par ailleurs, puisque notre abstraction se base sur un modèle de matrice tuilée, nous pouvons
bénéficier des derniers travaux de parallèlisation sur les produits de matrices. D’autre part,
un tel algorithme permettrait à termes d’explorer de nouvelles méthodes de compression jus-
qu’ici peu abordées dans la littérature. Une implémentation séquentielle de cet algorithme a
été réalisée dans la bibliothèque composyx tandis qu’une implémentation parallèle est prévue
dans de futurs travaux.

### Auteurs

- Antoine Gicquel (Inria Bordeaux)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #81

### Titre

Peut-on exprimer un produit de matrices distribué haute performance avec un modèle Map-Reduce ?

### Résumé

Le modèle de programmation fonctionnelle MapReduce a permis d’écrire de manière compacte, élégante et performante de nombreux algorithmes parallèles pour le traitement de données massives  sur  des  architectures  distribuées.  En  revanche,  il  n’est  sans  doute  pas  exagéré de penser que son utilisation effective pour la mise au point d’algorithmes de calcul haute performance (HPC) sur des supercalculateurs puisse être considérée comme ésotérique en 2025. Dans cette note, nous considérons un algorithme HPC étendard, à savoir le produit de matrices C←α·A·B+β·C (GEMM) et étudions si les schémas complexes de sa parallélisation posés dans la littérature peuvent être exprimés dans ce paradigme. Nous montrons qu’en enrichissant le modèle pour exprimer sur quels processus placer les données et effectuer les calculs, il est effectivement possible d’exprimer les schémas de parallélisation de la littérature du produit C←α·A·B. Nous montrons que cette expression ne permet cependant pas d’exprimer toute la localité d’accès aux données au sein d’un processus requise pour une performance optimale. Nous proposons finalement en enrichissant encore le modèle avec une troisième fonction inline_mapreduce (en sus de map et reduce), d’exprimer également cette localité et de supporter le cas plus général C←α·A·B+β·C. Un prototype de ce modèle MapReduce HPC a été implémenté au-dessus du moteur d’exécution StarPU.

### Auteurs

- Hugo Dodelin (INRIA Bordeaux)

### Sujet

- Parallélisme

### Type de présentation

Présentation avec poster

---

## Soumission #83

### Titre

A software-controlled hardware cache for memory disaggregation

### Résumé

Garbage collection (GC) is an automatic memory management technique essential for reclaiming memory occupied by dead objects. However, efficient garbage collection in distributed and memory-disaggregated systems faces significant challenges due to high synchronization overheads, cache pollution, and increased memory access latency. Specifically, synchronizing application and GC states often leads to cache pollution, degrading system performance, and requiring costly synchronization just to maintain a consistent memory snapshot for garbage collection.
  

In this work, we present a novel cache architecture integrating a software-controlled write-back barrier to efficiently support memory snapshotting for garbage collection. Our design introduces dynamic cache line pinning, ensuring dirty lines remain pinned until their contents are preserved in an undo log. This mechanism enables precise memory snapshotting, allowing the garbage collector to operate on a consistent memory state without incurring typical stop-the-world delays. Furthermore, modifications introduced within the QEMU emulation environment include enhancing the virtual address translation process in the software MMU, facilitating detailed simulation of cache behavior and its contents.


By decoupling garbage collection activities from the application's execution context, our proposed solution aims to significantly reduce synchronization overhead. Future work will focus on refining the cache control API, exploring hardware implementations via FPGA, and extending the methodology to other applications that could benefit from efficient, low-overhead memory snapshotting.

### Auteurs

- Nevena Vasilevska (Telecom SudParis)
- Julie Dumas (TIMA - Grenoble)
- Nicolas Derumigny (Telecom SudParis)
- Gael Thomas (Inria)

### Sujet

- Architecture

### Type de présentation

Présentation sans poster

---

